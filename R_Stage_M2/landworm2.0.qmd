---
title: "LandWorm 2.0"
subtitle: "Modeling and predicting earthworm diversity and distribution in France"
author: "Abdourahmane Diallo"
date: '`r Sys.Date()`'
format: revealjs
# preview-links: auto
# logo: logo-FRB-Cesab-francais.png
# css: styles.css
# footer: "LandWorm"
multiplex: true
#smaller: true
scrollable: true
incremental: FALSE
slide-level: 2
#theme: sky
editor: visual
number-sections: true
toc: FALSE
#toc-expand: false
#toc_float: 'yes'
code_download: 'yes'
slide-number: true
margin: 0.1
#center: true
code-fold: true
width: 1300
height: 700
toc_depth: 1
execute:
  cache: true
# quarto render landworm.qmd --cache-refresh
---


## Setting {.unnumbered}

```{r setup, include=FALSE,fig.align='center',message=FALSE,warning=FALSE,message=FALSE,echo=TRUE}
# rm(list=ls()) # Properly clear workspace
# source("function_abdou.R")
# knitr::opts_chunk$set(echo = TRUE)

```

```{css, echo=FALSE}
.title {
  font-size: 100px;
  font-style: italic;
  color: blue;
  font-family: Arial;
  font-variant: small-caps;
}
```

**Packages**

```{r packages,echo=TRUE}
  library(tidyverse)
  # library(glme)
  # library(lsmeans)
  # library(agricolae)
  # library(RVAideMemoire)
  library(corrplot)
  # library(emmeans)
  library(lme4)
  library(multcomp)
  library(MASS)
  # library(R2WinBUGS)
  library(arm)
  # library(performance)
  # library(AER)
  # library(AICcmodavg)
  # library(MuMIn)
  library(ade4)
  library(Hmisc)
  library(labdsv)
  library(vegan)
  library(cowplot)
  library(ggpubr)
  library(rstatix)
  library(patchwork)
  library(multcompView)
  library(ggsignif)
  library(grid)
  library(FactoMineR)
  library(factoextra)
  library(explore)
  library(ggrepel)
  library(naniar)
  library(outliers)
  library(leaps)
  library(fastDummies)
  library(caret) # pour l'entrainement des models
  library(mgcv)
  library(ggeffects)
  library(gratia)
  library(GGally) # pour ggpair
  # library(caTools)
  # library(rpart)
  # library(rpart.plot)
  library(openxlsx)
  library(readxl)
  library(leaflet) # pour la carto
  library(quarto)
  library(raster)
  library(knitr)
  library(kableExtra)
  library(stringr)
  library(plotly)
  # library(PerformanceAnalytics)
  # library(usdm)
  library(vcd) # pour la distribution des var reponse
  library(prospectr)# pour split data avec kenSton()
  # library(glmnet)
  library(randomForest)
  # library(doParallel)
  library(gbm)
  library(kernlab)
  # library(e1071)
  library(ggforce)
  library(keras)
  library(tensorflow)
  library(neuralnet)
  # library(parallel)
  library(iml) # pour l'interpretabilité des models https://cran.r-project.org/web/packages/iml/vignettes/intro.html
  library(stats)
  # library(Boruta) # importance des predicteurs
  library(bestNormalize)
  library(rmarkdown)
  library(DT)
  library(gtExtras) # pour la
  library(reshape2)
  # library(mapview)
  library(sf)
  library(ggplot2)
  library(maptools)
  library(ggsn)
  library(spThin)
  library(sp)
  library(gstat)
  library(rms)

```

**Functions**

```{r fonction, echo=TRUE}

## Identification des NA dans un df -----------------------------------------------
taux_completion<-
  function(df, afficher_zero_percent = FALSE, seuil, trie=FALSE) {
    # Calcule du pourcentage de NA dans le dataframe
    pourcentage_total <-
      round(sum(is.na(df)) / (nrow(df) * ncol(df)) * 100, 1)
    
    # Calcule du pourcentage de NA par colonne
    pourcentage_colonnes <- round(colMeans(is.na(df)) * 100, 1)
    
    # Creation d'un dataframe résultat avec deux colonnes
    result <-
      data.frame(
        Variables = names(df),
        CR = pourcentage_colonnes,
        row.names = NULL
      )
    
    if (afficher_zero_percent) {
      result <- result[result$CR == 0, ]
      result$CR = 100 -result$CR
    } else {
      result <- result[result$CR > 0, ]
      result$CR = 100 -result$CR
      
    }
    
    result <- rbind(result, c("Total", pourcentage_total))
    #result <- rbind(result, c("Total", paste0(pourcentage_total, "")))
    
    result <- result[, c("Variables", "CR")]
    result$CR = as.numeric(result$CR)
    result$CR = round(result$CR,1)
    if (trie){
      result = result %>% arrange(desc(CR))
    }
    result$CR = paste0(result$CR,"%")
    
    return(result)
  }
# Converssion des colonne en num ou factor-----------------------------------------------
conv_col <- function (data, columns_to_convert, to_types) {
  if (to_types == "numeric") {
    # Conversion des colonnes en numeric
    for (col in columns_to_convert) {
      data[, col] <- as.numeric(data[, col])
    }
  } else {
    # Conversion des colonnes en facteurs
    for (col in columns_to_convert) {
      data[, col] <- as.factor(data[, col])
    }
  }
  return(data)
}
#data_converted <- conv_col(data, names(data [, c(1, 3)]), "factor")

# exploration graphiques des variables numeriques -----------------------------------------------
explo_num <- function(nom_col, titre, df = landworm, ligne_col = c(2, 2),mini = min(df[[nom_col]]), maxi=max(df[[nom_col]]) ) {
  par(mfrow = ligne_col)
  
  df[complete.cases(df[[nom_col]]), ]
  df <- df %>%dplyr::filter(!is.na(df[[nom_col]]))
  df[[nom_col]] = as.numeric(df[[nom_col]])
  # Boxplot
  boxplot(df[[nom_col]], col = 'blue', ylab = titre, ylim = c(mini, maxi))
  # Cleveland plot
  # dotchart(df[[nom_col]], pch = 16, col = 'blue', xlab = titre)
  plot(df[[nom_col]], pch = 16, col = 'blue', ylab = titre)
  # Histogram
  hist(df[[nom_col]], col = 'blue', xlab = titre, main = "")
  # Quantile-Quantile plot
  qqnorm(df[[nom_col]], pch = 16, col = 'blue', xlab = '')
  qqline(df[[nom_col]], col = 'red') 
}

# Extraction des predictors + moyennes -----------------------------------------------

extraction <- function(nom_col, tif_file_path, df = landworm, conv = 1) {
  #df <- df %>%filter(!is.na(gps_x) & !is.na(gps_y))
  raster_data <- raster(tif_file_path)
  
  # Création d'un dataframe pour stocker les valeurs extraites
  df_interne <- data.frame(gps_x = df$gps_x, gps_y = df$gps_y)
  proj4Str <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
  # Transformer les coordonnées GPS en système de coordonnées du raster
  gps_coords_sp <- SpatialPoints(df_interne, proj4string = CRS(proj4Str))
  gps_coords_proj <- spTransform(gps_coords_sp, crs(raster_data))
  
  # Extraction des valeurs du raster 
  values <- raster::extract(raster_data, gps_coords_proj)
  
  # Ajout des valeurs extraites comme nouvelles colonnes a df
  #df_save = data.frame()
  #df_save[[nom_col]] <- values / conv
  
  df[[nom_col]] <- values / conv
  
  return(df)
}

# la moyenne des predictores -----------------------------------------------
moyenne_val_extrct <- function(nom_col, vec_col, df=landworm) {
  df[[nom_col]] <- rowMeans(as.matrix(df[, vec_col, drop = FALSE]), na.rm = TRUE)
  df[[nom_col]] = round(df[[nom_col]],1)
  return(as.data.frame(df))
}


# tests de corrélation avec un seuil -----------------------------------------------
cor_function_seuil <- function(data, seuil,affiche=FALSE) {
  # Création d'un vecteur pour stocker les paires de variables corrélées
  variables_corr <- c()
  
  # Boucle pour tester la corrélation entre chaque paire de variables
  for (i in 1:(ncol(data) - 1)) {
    for (j in (i + 1):ncol(data)) {
      # Calcul de la corrélation entre les variables i et j
      cor_value <- stats::cor(data[, i], data[, j], use = "na.or.complete")
      
      # Stockage du résultat dans le vecteur si supérieur au seuil
      if (cor_value >= seuil | cor_value <= -seuil) {
        if(affiche){
        cat(
          "***",
          colnames(data)[i],
          "  __est correlee a__  ",
          colnames(data)[j],
          "avec un R =",
          cor_value,
          "\n \n \n"
        )
      }
        
        variables_corr <-
          c(variables_corr, colnames(data)[i], colnames(data)[j])
      }
    }
  }
  
  return(variables_corr)
}


# tests de valeurs aberant -----------------------------------------------
test_grub <- function(data, variable, direction = "maxi") {
  
  if (direction == "maxi") { 
    repeat {
      #le test de Grubbs
      test_aberrant <- grubbs.test(data[[variable]], opposite = FALSE)
      
      # Obtenir la p-valeur du test
      p.value <- test_aberrant$p.value
      # Si la p-valeur est inférieure au seuil de 0.05, on supprime la valeur aberrante
      if (p.value < 0.05) {
        max_value <- max(data[[variable]],na.rm=TRUE)
        data <- subset(data, data[[variable]] != max_value | is.na(data[[variable]]))
      } else {
        # S'il n'y a plus de valeurs aberrantes, sortir de la boucle
        break
      }
    }
  }
  
  
  if (direction == "mini") { 
    repeat {
      test_aberrant <- grubbs.test(data[[variable]], opposite = TRUE)
      # Obtenir la p-valeur du test
      p.value <- test_aberrant$p.value
      # Si la p-valeur est inférieure au seuil de 0.05, on supprime la valeur aberrante
      if (p.value < 0.05) {
        min_value <- min(data[[variable]],na.rm=TRUE)
        data <- subset(data, data[[variable]] != min_value | is.na(data[[variable]]))
      } else {
        # S'il n'y a plus de valeurs aberrantes, sortir de la boucle
        break
      }
    }
  }
  
  
  return(data)
}




# boxplote -----------------------------------------------
plot_boxplot <-function(donnee,
           x_col,y_col,x_label,y_label,title,legend_title,
           couleurs,
           affiche_point = TRUE,
           ymin = min(donnee[[y_col]]),
           ymax = 1.2 * max(donnee[[y_col]])) {
    
  graphe <-ggplot(donnee,
             aes_string(
               x = x_col,
               y = y_col,
               colour = x_col
             )) +
  geom_boxplot(
        outlier.shape = NA,
        outlier.colour = "black",
        alpha = 0.20,
        size = 1.5 
      ) +
  labs(title = title,x = x_label,y = y_label) +
  scale_color_manual(values = couleurs, name = legend_title) +
  theme_classic(base_size = 12, base_family = "Arial") +
  theme(axis.text = element_text(size = 10),
        axis.title.y = element_text(
          vjust = 5, size = 12, face = "bold"),
        axis.title.x = element_text(face = "bold"),
        axis.ticks.length = unit(0.2, "cm"),
        legend.position = "none",  # Cette ligne supprime la legende
        #legend.position = "right",
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 12, face = "bold"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.title = element_text(size = 14, face = "bold"),
        plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm")
      )
    if (affiche_point) {
      graphe <-
        graphe + geom_jitter(position = position_jitter(seed = 0.5), size = 0.8)
    }
    
    if (y_col %in% names(donnee)) {
      graphe <- graphe +
        coord_cartesian(ylim = c(ymin, ymax))
    }
  
    graphe = graphe + stat_summary(
      fun.y = mean,
      geom = "point",
      shape = 15,
      size = 1.5,
      col = "black",
      fill = "black"
    )
    
    return(graphe)
}



#pour le  pairwise.t.test() -----------------------------------------------------
tri.to.squ <- function(x) {
  rn <- row.names(x)
  cn <- colnames(x)
  an <- unique(c(cn, rn))
  myval <- x[!is.na(x)]
  mymat <-
    matrix(
      1,
      nrow = length(an),
      ncol = length(an),
      dimnames = list(an, an)
    )
  for (ext in 1:length(cn))
  {
    for (int in 1:length(rn))
    {
      if (is.na(x[row.names(x) == rn[int], colnames(x) == cn[ext]]))
        next
      mymat[row.names(mymat) == rn[int], colnames(mymat) == cn[ext]] <-
        x[row.names(x) == rn[int], colnames(x) == cn[ext]]
      mymat[row.names(mymat) == cn[ext], colnames(mymat) == rn[int]] <-
        x[row.names(x) == rn[int], colnames(x) == cn[ext]]
    }
  }
  return(mymat)
}



# Selection interaction -------------------------------
select_inter <- function(response_var, df, explanatory_vars) {
  results <- data.frame()
  combinations <- combn(explanatory_vars, 2, simplify = FALSE)

  for(i in seq_along(combinations)) {

    formula <- as.formula(paste(response_var, "~", paste(combinations[[i]], collapse = "*")))
    model <- gam(formula, data = df)
    r_squared <- summary(model)$r.sq
    aic <- AIC(model)
    results <- rbind(results, data.frame("variables" = paste0(combinations[[i]], collapse = ".inter."), 
                                         "r_squared" = r_squared, 
                                 "aic" = aic))
  }
  return(results)
}

# Comparaion betwen predtited and observed -----------------------------------
plot_comp = function (df,ylabel, title_class, legende = TRUE,plotly = FALSE,xlabel = "observations",title=""){ 

  
  p = ggplot(df, aes(x = observation)) + 
  #graph representant observed
  geom_point(aes(y = Observed, color = "Observed values")) +
  geom_line(aes(y = Observed, color = "Observed values")) + 
  
  #graph representant  preticted
  geom_point(aes(y = Predicted, color="Predicted values")) +
  geom_line(aes(y = Predicted, color="Predicted values")) + 
  # ggtitle(title)
  theme(plot.title = element_text(hjust = 0.5)) + 
  labs(title = title,x=xlabel, y=ylabel, color = "Legend :") + 
  ylim(min(c(min(df$Predicted), min(df$Observed))),
            max(c(max(df$Predicted), max(df$Observed)))+1  ) +
    
  scale_color_manual(values = c("Observed values"='red', "Predicted values"='green')) +
  annotate("text", x = 8, y =  max(c(max(df$Predicted), max(df$Observed)))+1, 
           label = title_class, col = "black", size = 3)

  
  if (!legende) {
    p <- p + theme(legend.position = "none")
  }
  
  if(plotly){
    p = ggplotly(p)
  }

return (p)

}


# Calcul R² -----------------------------------
# calcule_R2 = function(x, y) {cor(x, y)^2}
calcule_R2 <- function(y_true, y_pred) {
  sse <- sum((y_true - y_pred)^2)
  sst <- sum((y_true - mean(y_true))^2)
  r_squared <- 1 - (sse / sst)
  return(r_squared)
}



# Fonction d'exploration graphique des relations entre les vd et les predictors -----------------------------------
nuage_point <- function(df, var_rep, predicteur, titre_x, titre_y) {
  # Convertir les variables en numeriques
  df[[predicteur]] <- as.numeric(df[[predicteur]])
  df[[var_rep]] <- as.numeric(df[[var_rep]])
  
  df= df[,c(predicteur,var_rep)]
  df = drop_na(df)
  # correlation entre les deux variables
  correlation <- round(cor(df[[predicteur]], df[[var_rep]]), 3)
  
  #  le graphique
  g <- ggplot(df, aes(x = !!rlang::sym(predicteur), y = !!rlang::sym(var_rep))) +
    geom_point() + # Ajout des points
    geom_smooth(method = "lm", se = TRUE, color = "red") + 
    labs(
      # title = paste("Relationship between",var_rep, "and", predicteur),
         subtitle = paste0(" r = ", correlation),
         x = titre_x, 
         y = titre_y) +
    theme_classic()   
  
  return(g)
}

box_plot <- function(df, var_rep, predicteur, titre_x, titre_y) {
  g <- ggplot(df, aes(x = !!rlang::sym(predicteur), y = !!rlang::sym(var_rep))) +
    geom_boxplot() + # Ajout des boxplots
    labs(
      # title = paste("Boxplot of", var_rep, "by", predicteur),
         x = titre_x, 
         y = titre_y) +
    theme_classic()   
  
  print(g)
}
```






# Database import

-   Import of database **LandWorm_dataset_site_01_07_2024.xlsx** (february 22, 2024)

```{r import,echo=FALSE}
chemin_fichier_excel = "C:/Users/diall/Downloads/datas/LandWorm_dataset_site_01_07_2024.xlsx"
landworm <- read.xlsx(chemin_fichier_excel, sheet = "Sheet1")

```

-   The database contains **`r nrow(landworm)`** rows and **`r ncol(landworm)`** columns

```{r conversion,echo=FALSE}
col_en_factor = c("Programme","Annee","ID_Site","Code_Parcelle","postal_code","clcm_lvl1", "clcm_lvl2","clcm_lvl3","Modalite","Bloc","Protocole","land_cover_detail","type_tillage","fertilisation","ferti_min_product","ferti_orga_product")
landworm = conv_col(landworm, col_en_factor, "factor")
```

**Columns with only NAs**

To make the dataset easier to read, I identify and remove all columns with only NA:

```{r}
cols_with_all_na <- apply(landworm, 2, function(col) all(is.na(col)))
print(names(landworm)[cols_with_all_na])
landworm <- landworm[, !cols_with_all_na]
```

-   The database contains **`r nrow(landworm)`** rows and **`r ncol(landworm)`** columns

## Protocols (avant séléction)

-   **List of protocols available on the database ( `r length(levels(landworm$Protocole))` levels)**

```{r protocols1,echo=TRUE}
landworm$Protocole = as.factor(landworm$Protocole)
df <- as.data.frame(summary(landworm$Protocole))
colnames(df) <- c("Numbers")
DT::datatable(df, options = list(pageLength = 5))
rm("df")
```


-   **Selection of protocols: 16** 

```{r}
df_suivi = landworm
n_line = nrow(df_suivi)

sel_proto = c("AITC_HS","FHS","HS","HS_4","HS_M_16","HSAITC_16","HSAITC_6.25","AITCTM","F_HS","hand sorting","HS_16","HS_F_16","HS_M_25","HSAITC_4",
    "HSAITC_7.95775385","M_HS")

sel_proto = c("AITCTM", "AITC_HS", "HS", "F_HS", "M_HS", "HS_M_16", "HS_M_25" , "HS_F_16", "HS_16" , "HSAITC_7.95775385",  "HSAITC_6.25" , "HS_4" , "HSAITC_4" ,"FHS","HSAITC_16" , "hand sorting")

landworm2 <- landworm
n_line = nrow(landworm2)
landworm2 <- landworm2 %>%
  dplyr::filter(Protocole %in% sel_proto)
landworm2 <- droplevels(landworm2)
df = landworm2 %>%
  pull(Protocole) %>%
  table() %>%
  as.data.frame() %>%
  dplyr::rename(Numbers = 2) 

# kable(df)
df %>% datatable(options = list(pageLength = 5))

landworm = landworm2
rm("landworm2")
```


-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.




## Data selection: LandWorm

-   On séléctionne tout sauf *NA*
```{r selection owner1,echo=FALSE}


landworm$owner=as.factor(landworm$owner)
summary_df <- as.data.frame(summary(landworm$owner))
colnames(summary_df) <- c("Numbers")
kable(summary_df)
```

```{r selection owner2,echo=TRUE}
df_suivi = landworm
n_line = nrow(df_suivi)

landworm <- subset(landworm, owner %in% c("dc","cp","gp","sg", "mh"))
landworm$owner=droplevels(landworm$owner)

```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

# Database exploration

-   CR = Completion rate

## Complete columns

```{r Complete columns, echo=TRUE}
df_col=taux_completion(landworm,TRUE,trie=FALSE)
df_col = df_col[df_col$Variables != "Total",]
#print("table")
kable(df_col, caption = "", col.width = c("75%", "25%"))
# cat(                                                    )
# head(landworm[, "ID"])
```

## Non-complete columns

```{r Non-complete columns}
df_col= taux_completion(landworm,FALSE,trie = TRUE)
df_col = df_col[df_col$Variables != "Total",]
# kable(df_col, caption = " ", col.width = c("75%", "25%"))

df_col %>% datatable(options = list(pageLength = 10), rownames = FALSE)

```

## Focus on GPS coordinates

-   There is **`r sum(is.na(landworm$gps_x))`** NA in **GPS_X**
-   There is **`r sum(is.na(landworm$gps_y))`** NA in **GPS_Y**

```{r GPS,echo=TRUE}

df_suivi = landworm
n_line = nrow(df_suivi)

# landworm$gps_x <- as.numeric(gsub("[^0-9.-]", "", landworm$gps_x))
# landworm$gps_y <- as.numeric(gsub("[^0-9.-]", "", landworm$gps_y))
landworm <- landworm[complete.cases(landworm$gps_x, landworm$gps_y), ]
landworm <- landworm %>%dplyr::filter(!is.na(gps_x) & !is.na(gps_y))
#sum(is.na(landworm$gps_x))
#sum(is.na(landworm$gps_y))
```

-   We delete the *NA* lines in the GPS coordinates
-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## Cartography

```{r Cartography,echo=TRUE}
df_suivi = landworm
n_line = nrow(df_suivi)

df_coord <- landworm[, c("gps_x", "gps_y")] %>% mutate(gps_x = as.numeric(gps_x),gps_y = as.numeric(gps_y))

df_coord$num_ligne <- seq(nrow(df_coord))
carte <- leaflet(df_coord) %>%
  addTiles() %>%
  addCircleMarkers(lng = ~gps_x, lat = ~gps_y, radius = 0.8, fillOpacity = 0.8, fillColor = "blue")
carte
```

```{r outside France}
hors_france= read.csv(file = "C:/Users/diall/Downloads/datas/hors_france.csv", header = TRUE)

landworm <- landworm[!(landworm$gps_x %in% hors_france$gps_x & landworm$gps_y %in% hors_france$gps_y), ]
landworm <- droplevels(landworm)
```

-   We delete points outside France (**`r nrow(hors_france)`**)
-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

## Focus on years

-   Cleaning the Annee column 
<br/> 

```{r years1}
df_suivi = landworm
n_line = nrow(df_suivi)

# levels(landworm$Annee) # parfois années et jours et ou mois
landworm$Annee= as.factor(landworm$Annee)
landworm$Annee <- gsub("^(\\d{4}).*$", "\\1", landworm$Annee) # on prend uniquement les 04 premier chiffre
landworm$Annee= as.factor(landworm$Annee)

levels_current <- levels(landworm$Annee)

# Extraire uniquement l'année pour les niveaux au format "MM_YYYY"
years <- ifelse(grepl("_", levels_current), 
                substr(levels_current, nchar(levels_current) - 3, nchar(levels_current)), 
                levels_current)


levels(landworm$Annee) <- years

landworm$Annee= as.factor(landworm$Annee)

```


-   CR of Annee = **`r df_col[df_col$Variable=="Annee", "CR"]`** (`r length(levels(landworm$Annee))` levels)

```{r years2, scrollable = TRUE}
landworm$Annee= as.factor(landworm$Annee)
landworm = droplevels(landworm)
summary_df <- data.frame(Numbers = summary(landworm$Annee))
summary_df$Annee = rownames(summary_df)
summary_df = summary_df[,c("Annee", "Numbers")]
rownames(summary_df) = NULL
summary_df = summary_df %>% arrange(Annee)
summary_df %>% datatable(options = list(pageLength = 10))
rm("summary_df")
```



-   We remove all the years before **1990** and the NA ( *`r sum(is.na(landworm$Annee))`* observations) 

```{r years3, echo=TRUE, scrollable = TRUE}
# sum(is.na(landworm$Annee))
landworm <- landworm %>%dplyr::filter(!is.na(Annee))# on enleve les NA
annes_omit= c("1821", "1960", "1978", "1982", "1983", "1984", "1986", "1988", "1989", "1905") # annee sup
landworm <- landworm[!landworm$Annee %in% annes_omit, ]
landworm=droplevels(landworm)
summary_df <- data.frame(Numbers = summary(landworm$Annee))
summary_df$Annee = rownames(summary_df)
summary_df = summary_df[,c("Annee", "Numbers")]
rownames(summary_df) = NULL
summary_df = summary_df %>% arrange(Annee)
summary_df %>% datatable(options = list(pageLength = 10))
rm("summary_df")
```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations. 





## Focus on clcm_lvl1

-   CR of clcm_lvl1 = **`r df_col[df_col$Variable=="clcm_lvl1","CR"]`** (`r length(levels(landworm$clcm_lvl1))` levels)

```{r clcm_lvl1, echo=TRUE}
landworm$clcm_lvl1= as.factor(landworm$clcm_lvl1)
summary_df <- as.data.frame(summary(landworm$clcm_lvl1))
colnames(summary_df) <- c("Numbers")
kable(summary_df,padding = 5)
```

-   Merging levels

```{r merging clcm_lvl1, echo=TRUE}
levels(landworm$clcm_lvl1)[levels(landworm$clcm_lvl1) == "1_Naturel"] <- "Forest and semi natural areas"
levels(landworm$clcm_lvl1)[levels(landworm$clcm_lvl1) == "2_Agricole"] <- "Agricultural areas"

levels(landworm$clcm_lvl1)[levels(landworm$clcm_lvl1) == "Territoires agricoles"] <- "Agricultural areas"

landworm$clcm_lvl1= as.factor(landworm$clcm_lvl1)
summary_df <- as.data.frame(summary(landworm$clcm_lvl1))
colnames(summary_df) <- c("Numbers")
kable(summary_df,padding = 5)
```

-   Update **code_clcm_lvl1**

```{r code_clcm_lvl1, echo=TRUE}
#landworm$code_clcm_lvl1 = as.factor(landworm$code_clcm_lvl1)

landworm$code_clcm_lvl1 <- ifelse(landworm$clcm_lvl1 == "Forest and semi natural areas", 3, landworm$code_clcm_lvl1)

landworm$code_clcm_lvl1 <- ifelse(landworm$clcm_lvl1 == "Agricultural areas", 2, landworm$code_clcm_lvl1)
```

-   For the moment, we will keep the NA of **clcm_lvl1**

## Focus on clcm_lvl2

-   CR of clcm_lvl2 = **`r df_col[df_col$Variable=="clcm_lvl2","CR"]`** (`r length(levels(landworm$clcm_lvl2))` levels)

```{r clcm_lvl2 , echo=TRUE}
landworm$clcm_lvl2= as.factor(landworm$clcm_lvl2)
summary_df <- as.data.frame(summary(landworm$clcm_lvl2))
colnames(summary_df) <- c("Numbers")
summary_df %>% datatable(options = list(pageLength = 5))
```

-   Merging levels

```{r merging clcm_lvl2, echo=TRUE}
levels(landworm$clcm_lvl2)[levels(landworm$clcm_lvl2) == "21_Agricole ouvert"] <- "Arable land"

landworm$clcm_lvl2= as.factor(landworm$clcm_lvl2)
summary_df <- as.data.frame(summary(landworm$clcm_lvl2))
colnames(summary_df) <- c("Numbers")
# kable(summary_df,padding = 5)
summary_df %>% datatable(options = list(pageLength = 10), rownames = TRUE)
```

-   Update **code_clcm_lvl2**

```{r code_clcm_lvl2, echo=TRUE}

landworm$code_clcm_lvl2 <- ifelse(landworm$clcm_lvl2 == "Arable land", 21, landworm$code_clcm_lvl2)

```

## Focus on clcm_lvl3

-   CR of clcm_lvl3 = **`r df_col[df_col$Variable=="clcm_lvl3","CR"]`** (`r length(levels(landworm$clcm_lvl3))` levels)

```{r clcm_lvl3, echo=TRUE, scrollable = TRUE}
df_suivi = landworm
n_line = nrow(df_suivi)

landworm$clcm_lvl3= as.factor(landworm$clcm_lvl3)
summary_df <- as.data.frame(summary(landworm$clcm_lvl3))
colnames(summary_df) <- c("Numbers")
# kable(summary_df,padding = 5)
summary_df %>% datatable(options = list(pageLength = 10), rownames = TRUE)
```

## Land use selection (clcm_lvl3)



-   **Broad-leaved forest** 
-   **Indetermined forest** 
-   **Mixed forest**
-   **Urban forest and woodland** 

-   **Pastures, meadows and other permanent grasslands under agricultural use** 

-   **Non-irrigated arable land** 

-   **Vineyards**

-   **Green urban areas**

-   **Natural grasslands**


```{r select clcm_lvl3, echo=TRUE}
# select_os= c("Broad-leaved forest", "Coniferous forest", "Mixed forest", 
# "Pastures, meadows and other permanent grasslands under agricultural use", "Non-irrigated arable land", "Vineyards","Green urban areas","Natural grasslands")

select_os= c("Broad-leaved forest", "Mixed forest", "Indetermined forest", 
             "Urban forest and woodland", "Pastures, meadows and other permanent grasslands under agricultural use", "Non-irrigated arable land", "Vineyards","Green urban areas","Natural grasslands")


landworm <- landworm[landworm$clcm_lvl3 %in% select_os, ]
landworm=droplevels(landworm)
landworm$clcm_lvl3 = as.factor(landworm$clcm_lvl3)
summary_df <- as.data.frame(summary(landworm$clcm_lvl3))
colnames(summary_df) <- c("Numbers")
summary_df %>% datatable(options = list(pageLength = 5))

```

-   **We merge the 4 types of forest: **

    -   **Broad-leaved forest** 
    -   **Indetermined forest** 
    -   **Mixed forest**
    -   **Urban forest and woodland** 

```{r}
landworm$clcm_lvl3= as.factor(landworm$clcm_lvl3)
levels(landworm$clcm_lvl3)[levels(landworm$clcm_lvl3)=="Broad-leaved forest"]="Forest"
levels(landworm$clcm_lvl3)[levels(landworm$clcm_lvl3)=="Mixed forest"]="Forest"
levels(landworm$clcm_lvl3)[levels(landworm$clcm_lvl3)=="Urban forest and woodland"]="Forest"
levels(landworm$clcm_lvl3)[levels(landworm$clcm_lvl3)=="Indetermined forest"]="Forest"
# levels(landworm$clcm_lvl3)[levels(landworm$clcm_lvl3) == "Coniferous forest"] <- "Forest"


landworm$clcm_lvl3= as.factor(landworm$clcm_lvl3)
landworm = droplevels(landworm)

summary_df <- as.data.frame(summary(landworm$clcm_lvl3))
colnames(summary_df) <- c("Numbers")
summary_df %>% datatable(options = list(pageLength = 5))

```


-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.



## Focus on protocols (après séléction)

-   List of protocols available on the database ( `r length(levels(landworm$Protocole))` levels)

```{r protocols,echo=TRUE}
landworm$Protocole = as.factor(landworm$Protocole)
summary_df <- as.data.frame(summary(landworm$Protocole))
colnames(summary_df) <- c("Numbers")
summary_df %>% datatable(options = list(pageLength = 5))

```


-   Merging levels :

    -   F_HS $=$ F_HS $+$ FHS
    -   HS $=$ HS $+$ hand sorting

```{r merging protocols,echo=TRUE}
levels(landworm$Protocole)[levels(landworm$Protocole) == "FHS"] <- "F_HS"
levels(landworm$Protocole)[levels(landworm$Protocole) == "hand sorting"] <- "HS"
landworm$Protocole = as.factor(landworm$Protocole)
summary_df <- as.data.frame(summary(landworm$Protocole))
colnames(summary_df) <- c("Numbers")
summary_df %>% datatable(options = list(pageLength = 5))
```

## Land use & protocol overview

```{r LU & protocol overview, echo=TRUE}
# kable (table(landworm$clcm_lvl1, landworm$Protocole,exclude = NULL), align = "c", format = "pipe", padding = 10)
# kable (table(landworm$clcm_lvl2, landworm$Protocole,exclude = NULL), align = "c", format = "pipe", padding = 10)
df = table(landworm$clcm_lvl3, landworm$Protocole,exclude = NULL)
# df = as.data.frame(df)
kable (df, align = "c", format = "pipe", padding = 10)

# df %>% datatable(options = list(pageLength = 8))
```




# Earthworms data


## Total abundance

```{r fig AB_tot,fig.align='center',fig.height=10}

df_suivi = landworm
n_line = nrow(df_suivi)

AB_tot_aberant = landworm[,c("ID","Programme", "Annee", "ID_Site","clcm_lvl1","clcm_lvl2","clcm_lvl3","Protocole","AB_tot")]
# summary(landworm$AB_tot) 
df_cleaned = landworm

df_cleaned$AB_tot = as.numeric(df_cleaned$AB_tot)
explo_num(nom_col = 'AB_tot', titre = 'AB_tot (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'AB_tot', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'AB_tot', direction = 'mini')
cat("Sppression des valeurs aberrantes")
explo_num(nom_col = 'AB_tot', titre = 'AB_tot (after cleaning)', df = df_cleaned)
# summary(df_cleaned$AB_tot) 
landworm = df_cleaned
```


-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.



<!-- ## Graphe valeurs aberant AB_tot -->

```{r,fig.align='center', echo=FALSE, eval=FALSE}
# summary(AB_tot_aberant)
AB_tot_aberant_2 = AB_tot_aberant[AB_tot_aberant$AB_tot > max(landworm$AB_tot),]
AB_tot_aberant_2$clcm_lvl1 =as.factor(AB_tot_aberant_2$clcm_lvl1)
AB_tot_aberant_2$clcm_lvl2 =as.factor(AB_tot_aberant_2$clcm_lvl2)
AB_tot_aberant_2$clcm_lvl3 =as.factor(AB_tot_aberant_2$clcm_lvl3)
AB_tot_aberant_2 = droplevels(AB_tot_aberant_2)
kable(unique(AB_tot_aberant_2[,c("Programme","Annee","clcm_lvl3")]))

df = AB_tot_aberant_2
df$observation = 1:nrow(df)
df$Richesse_tot_10 = df$Richesse_tot*100
g_AB_tot_aberant = ggplot(df, aes(x = observation)) + 
  geom_point(aes(y = AB_tot, color = "Abundance")) +
  geom_line(aes(y = AB_tot, color = "Abundance")) + 
  geom_point(aes(y = Richesse_tot_10, color="Richness*100")) +
  geom_line(aes(y = Richesse_tot_10, color="Richness*100")) + 
  # ggtitle(title)
  theme(plot.title = element_text(hjust = 0.5)) + 
  labs(title = "  ",x="Observation", y="Values", color = "Legend:") +
  scale_color_manual(values = c("Abundance"='red', "Richness*100"='green'))
# ggsave("g_AB_tot_aberant.png", plot = g_AB_tot_aberant, dpi = 300)
 # ggplotly(g_AB_tot_aberant)
 g_AB_tot_aberant
 
```



## Total biomass 

```{r fig BM_tot,fig.align='center',fig.height=10}

df_suivi = landworm
n_line = nrow(df_suivi)

# summary(landworm$BM_tot) 
df_cleaned = landworm

df_cleaned$BM_tot = as.numeric(df_cleaned$BM_tot)
explo_num(nom_col = 'BM_tot', titre = 'BM_tot (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'BM_tot', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'BM_tot', direction = 'mini')
cat("Sppression des valeurs aberrantes")
explo_num(nom_col = 'BM_tot', titre = 'BM_tot (after cleaning)', df = df_cleaned)
# summary(df_cleaned$BM_tot) 
landworm = df_cleaned
```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## Total taxonomic richness
```{r}
landworm_sp = landworm
```

**Total richness calculation method**

-   1.    Removal of columns with only NA and/or only 0

```{r step 1, echo=FALSE}
df_suivi = landworm_sp
n_line = nrow(df_suivi)

# on supprime tout les colonnes ayant que des NA
colonnes_na <- colnames(landworm_sp)[colSums(is.na(landworm_sp)) == nrow(landworm_sp)]
# summary(landworm_sp[, colonnes_na])
landworm_sp <- landworm_sp[, !colnames(landworm_sp) %in% colonnes_na]


# On supprimme toutes les colonnes ayant que des NA et des 0
colonnes_numeriques <- sapply(landworm_sp, is.numeric)
somme_colonnes_numeriques <- colSums(landworm_sp[, colonnes_numeriques],na.rm=TRUE)
colonnes_zeros <- names(somme_colonnes_numeriques[somme_colonnes_numeriques == 0])
#summary(landworm_sp[, colonnes_zeros])
landworm_sp <- landworm_sp[, !colnames(landworm_sp) %in% colonnes_zeros]
```


-   2.    Merging sub-species with their species
```{r step 2, echo=FALSE}
chemin_fichier_excel = "C:/Users/diall/Downloads/datas/choix_concaténation espèce_V2024.05.30.xlsx"
df_sp_sous_sp= read.xlsx(chemin_fichier_excel, sheet = "rules_1")

cat("Voici la liste des sp a fusionnée: \n")
df= df_sp_sous_sp
df$Rules = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))

```


```{r, echo=TRUE}
# function pour fusion les sous especes a leurs especes
sp_identique = function(df, nom_sous_espece, nom_espece ) {
  
  # Si les deux colonnes existent dans df
  if (nom_sous_espece %in% names(df) && nom_espece %in% names(df)) {
    
    # Addition des valeurs des deux colonnes et stockage du résultat dans nom_espece
    # df[[nom_espece]] = df[[nom_sous_espece]] + df[[nom_espece]]
    df[[nom_espece]] = rowSums(df[,c(nom_sous_espece,nom_espece)], na.rm = TRUE)
    

    df[[nom_sous_espece]] = NULL
  
  # Si nom_espece n'existe pas dans df mais nom_sous_espece existe
  } else if (nom_sous_espece %in% names(df) && !(nom_espece %in% names(df))) {
    
    # on renome nom_sous_espece par nom_espece
    names(df)[names(df) == nom_sous_espece] <- nom_espece
    df[[nom_sous_espece]] = NULL
  }
  
  return(df)
}


for (i in 1:nrow(df_sp_sous_sp)){
 
landworm_sp = sp_identique(df = landworm_sp,nom_sous_espece = df_sp_sous_sp[i,"col_sp_origines"],
                  nom_espece = df_sp_sous_sp[i,"col_sp_concatener"]) 
}

```

-   3.    Identify columns beginning with **AB\_**
```{r step 3, echo=FALSE}
# On récupère toutes les colonnes qui commencent par **AB_**
colonnes_AB <- grep("^AB_", names(landworm_sp), value = TRUE)
```


-   4.    Deletion of **AB\_** columns that are not species
```{r step 4, echo = TRUE}
# On supprimme les colonnes AB_ qui ne sont pas des espèces dans le calcule
ab_supprimee =  c("AB_AD",
                  "AB_JV",
                  "AB_SA",
                  "AB_STAD_X",
                  "AB_indéterminable",
                  "AB_Indéterminable",
                  "AB_indéterminable_endogeic",
                  "AB_tot",
                  "AB_Indéterminable_epigeic",
                  "AB_indéterminable_endogeic",
                  "AB_Ep.X",
                  "AB_vide",
                  "AB_Ep.X1",
                  "AB_Ep.X2",
                  "AB_A.X",
                  "AB_Adult",
                  "AB_cocon",
                  "AB_indéterminé",
                  "AB_Juvenile",
                  "AB_Sub.adult",
                  "AB_Indéterminé")

colonnes_AB <- colonnes_AB[!colonnes_AB %in% ab_supprimee]

cat("A ce stade, la liste des especes est: \n")
df= data.frame(colonnes_AB)
rownames(df) = NULL
DT::datatable(df, options = list(pageLength = 5))
```

-   5.    Calculate richness by assigning **1** to each column if the value is different from 0 and NA

<!-- -   Total richness = **1** if the plot has a value in AB and/or BM -->

A ce stade, la richesse varie de:

```{r step 5, echo=TRUE}
# On calcule la richesse en attribiant 1 à chaque colonne si la valeur est différent de 0 et de NA
landworm_sp$Richesse_tot <- 0
landworm_sp$Richesse_tot <- rowSums(!is.na(landworm_sp[colonnes_AB]) & landworm_sp[colonnes_AB] != 0)
#sum (is.na(landworm_sp$Richesse_tot) )
summary(landworm_sp$Richesse_tot)

```


-   6.    Décremmentation de la richesse

Voir code:

```{r step 6, echo=TRUE}
# Apres calcule richesse ------------------------------------------------------
sp_prorata <- function(df, sp_x, sp) {
  
  name_col <- names(df)
  
  #  si la colonne sp_x est présente
  if (sp_x %in% name_col) {
    
    # pour chaque ligne 
    for (i in 1:nrow(df)) {
      
      #  si les valeurs de la colonne sp_x ne sont ni 0 ni NA
      if (!is.na(df[i, sp_x]) && df[i, sp_x] != 0) {
        
        # Si la somme des ab des sp est différente de 0
        if (rowSums(df[i, sp], na.rm = TRUE) != 0) {
          # La richesse diminue de 1
          df[i, "Richesse_tot"] <- df[i, "Richesse_tot"] - 1
        }
      }
    }
  }
  
  return(df)
}

# Pour AB_Allolobophora_sp ------------------------------------------
sp_x = "AB_Allolobophora_sp"
sp=c("AB_Allolobophora_burgondiae",	
     "AB_Allolobophora_chlorotica",			
     "AB_Aporrectodea_cupulifera",	
     "AB_Aporrectodea_icterica",	
     "AB_Aporrectodea_limicola",	
     "AB_Aporrectodea_rosea")
# df= landworm_sp[, c(sp_x,sp, "Richesse_tot")]
# df=df[!df$AB_Allolobophora_sp == 0,]
# df=df[! is.na(df$AB_Allolobophora_sp),]
# df$som = rowSums(df[,sp], na.rm=TRUE)
# View(df)
# 
# dff <- sp_prorata(landworm_sp, sp_x, sp)
# dff= dff[, c(sp_x,sp, "Richesse_tot")]
# dff=dff[!dff$AB_Allolobophora_sp == 0,]
# dff=dff[! is.na(dff$AB_Allolobophora_sp),]
# dff$som = rowSums(dff[,sp], na.rm=TRUE)
# View(dff)
landworm_sp <- sp_prorata(landworm_sp, sp_x, sp)


# Pour AB_Aporrectodea_indéterminable ------------------------------------------
sp_x = "AB_Aporrectodea_indéterminable"
sp=c("AB_Allolobophora_burgondiae",	
     "AB_Allolobophora_chlorotica",
     "AB_Aporrectodea_cupulifera",
     "AB_Aporrectodea_icterica",
     "AB_Aporrectodea_limicola",
     "AB_Aporrectodea_rosea")
landworm_sp <- sp_prorata(landworm_sp, sp_x, sp)


# Pour AB_Aporrectodea_sp ------------------------------------------
sp_x = "AB_Aporrectodea_sp"
sp=c("AB_Aporrectodea_giardi",	
     "AB_Aporrectodea_longa",	
     "AB_Aporrectodea_nocturna",
     "AB_Aporrectodea_ripicola",
     "AB_Aporrectodea_longa/giardi")
landworm_sp <- sp_prorata(landworm_sp, sp_x, sp)



# Pour AB_Dendrobaena_sp ------------------------------------------
# Tous les "Dendrobaena" et "Dendrodrilus_rubidus" + Satchellius mammalis
sp_x = "AB_Dendrobaena_sp"
sp=c("AB_Dendrobaena_alpina",     
     "AB_Dendrobaena_attemsi",
     "AB_Dendrobaena_cognettii",
     "AB_Dendrobaena_hortensis",      
     "AB_Dendrobaena_octaedra",
     "AB_Dendrodrilus_rubidus",
     "AB_Satchellius_mammalis")
landworm_sp <- sp_prorata(landworm_sp, sp_x, sp)


# Pour AB_Eisenia_sp ------------------------------------------
# Tous les Eisenia possible
sp_x = "AB_Eisenia_sp"
sp=c("AB_Eisenia_andrei",
     "AB_Eisenia_fetida",
     "AB_Eisenia_veneta",             
     "AB_Eiseniella_tetraedra")
landworm_sp <- sp_prorata(landworm_sp, sp_x, sp)


# Pour AB_Lumbricus_sp  ------------------------------------------
# Tous les Lumbricus sauf Lumbricus castaneus ?
sp_x = "AB_Lumbricus_sp"
sp=c("AB_Lumbricus_centralis",       
"AB_Lumbricus_festivus",         
"AB_Lumbricus_friendi",          
"AB_Lumbricus_herculeus",        
"AB_Lumbricus_meliboeus",        
"AB_Lumbricus_rubellus" ,        
"AB_Lumbricus_terrestris",
"AB_Lumbricus_friendi/centralis")
landworm_sp <- sp_prorata(landworm_sp, sp_x, sp)



# Pour AB_Microscolex_sp  ------------------------------------------
# Tous les AB_Microscolex
sp_x = "AB_Microscolex_sp"
sp=c("AB_Microscolex_dubius",         
"AB_Microscolex_phosphoreus")
landworm_sp <- sp_prorata(landworm_sp, sp_x, sp)



# Pour AB_Octolasion_sp  ------------------------------------------
# Tous les AB_Octolasion
sp_x = "AB_Octolasion_sp"
sp=c("AB_Octodrilus_complanatus",    
"AB_Octolasion_cyaneum",         
"AB_Octolasion_lacteum")
landworm_sp <- sp_prorata(landworm_sp, sp_x, sp)



# Pour AB_Pheretima_indéterminable  ------------------------------------------
# AB_Pheritima_Diffringens
sp_x = "AB_Pheretima_indéterminable"
sp=c("AB_Pheritima_Diffringens", "AB_Pheritima_Diffringens")
landworm_sp <- sp_prorata(landworm_sp, sp_x, sp)



# Pour AB_Prosellodrilus_sp  ------------------------------------------
# Tous les Prosellodrilus
sp_x = "AB_Prosellodrilus_sp"
sp=c("AB_Prosellodrilus_amplisetosus",
"AB_Prosellodrilus_fragilis",    
"AB_Prosellodrilus_occidentalis",
"AB_Prosellodrilus_praticola",   
"AB_Prosellodrilus_pyrenaicus")
landworm_sp <- sp_prorata(landworm_sp, sp_x, sp)



# Pour AB_Scherotheca_sp  ------------------------------------------
# Tous les AB_Scherotheca_sp
sp_x = "AB_Scherotheca_sp"
sp=c("AB_Satchellius_mammalis",       
"AB_Scherotheca_aquitana",       
"AB_Scherotheca_dinoscolex",     
"AB_Scherotheca_nivicola",       
"AB_Scherotheca_porotheca",      
"AB_Scherotheca_rhodana",       
"AB_Scherotheca_savignyi")
landworm_sp <- sp_prorata(landworm_sp, sp_x, sp)

```


-   7.    Rules 3: Si le Owner de la parcelle est DC ou GP alors si Aporrectodea_trapezoides et/ou Aporrectodea_tuberculata sont presentent dans la parcelle alors si Aporrectodea_caliginosa est presente aussi dans la parcelle alors la richesse diminue de 1.

```{r step 7, echo=TRUE}

# dff <- data.frame(
#   owner = c("DC", "GP", "XX", "DC"),
#   AB_Aporrectodea_trapezoides = c(1, NA, 0, 2),
#   AB_Aporrectodea_tuberculata = c(NA, 0, 1, 3),
#   AB_Aporrectodea_caliginosa = c(2, 1, NA, 4),
#   Richesse_tot = c(10, 20, 30, 40)
# )
# df <- dff

df=landworm_sp
for (i in 1:nrow(df)) {
  # Si owner est "DC" ou "GP"
  if (df[i, "owner"] %in% c("DC", "GP")) {
    
    # si AB_Aporrectodea_trapezoides ou AB_Aporrectodea_tuberculata sont présents et non nuls
    if ((!is.na(df[i, "AB_Aporrectodea_trapezoides"]) && 
         df[i, "AB_Aporrectodea_trapezoides"] != 0) 
        || 
        (!is.na(df[i, "AB_Aporrectodea_tuberculata"]) && 
         df[i, "AB_Aporrectodea_tuberculata"] != 0)) {
      
      #  si AB_Aporrectodea_caliginosa est présente et non nulle
      if (!is.na(df[i, "AB_Aporrectodea_caliginosa"]) && 
          df[i, "AB_Aporrectodea_caliginosa"] != 0) {
        
        # La richesse diminue de 1 pour cette ligne
        df[i, "Richesse_tot"] <- df[i, "Richesse_tot"] - 1
      }
    }
  }
}

landworm_sp = df
```

-   8.    Rules 4: Si la Richesse_tot est superieur à 2 et que AB_Lumbricidae
et/ou AB_Oligochaeta_so est presente (differente de 0 et de NA), la Richesse_tot dimunue de -1

```{r step 8}
# df = landworm_sp
# 
# df <- df %>%
#   mutate(Richesse_tot = ifelse(Richesse_tot > 2 & 
#             (!is.na(AB_Lumbricidae) & AB_Lumbricidae != 0 | 
#              !is.na(AB_Oligochaeta_so) & AB_Oligochaeta_so != 0),
#                                Richesse_tot - 1, 
#                                Richesse_tot))
# landworm_sp =df
```



-   9.    Verifications

```{r step 9, echo=FALSE}
# Check des lignes ayant des 0 richesse et X AB ou BM : 0 lignes
# vdt_a_checker = landworm_sp[landworm_sp$Richesse_tot == 0 & (landworm_sp$Total_AB !=0 | landworm_sp$BM_to !=0), c("ID_Site","AB_tot","BM_tot","Richesse_tot")]
# vdt_a_checker = subset(vdt_a_checker, Richesse_tot==0)
# View(vdt_a_checker)
# vdt_a_checker$Richesse_tot <- 1
# Mettre à jour les ligne correspondant dans la landworm_sp 
# landworm_sp[rownames(landworm_sp) %in% rownames(vdt_a_checker), "Richesse_tot"] <- 1



# Check si y a des ligne ayant que des NA dans AB, BM et Richesse : nop
# resultat <- subset(landworm_sp, is.na(AB_tot) & is.na(BM_tot) & is.na(Richesse_tot))
# View(resultat[, c("AB_tot","BM_tot", "Richesse_tot")])



# Check si y a des ligne ayant que des zéros ou des NA dans AB, BM et Richesse_tot: 70 ligne
# vdt <- c("AB_tot", "BM_tot", "Richesse_tot")
# lignes_zero <- which(rowSums(landworm_sp[vdt] != 0, na.rm = TRUE) == 0)
# View(landworm_sp[lignes_zero,c("ID_Site","AB_tot", "BM_tot", "Richesse_tot")])



# Check des lignes ayant de BM mais pas de AB
# bm_sans_ab <- subset(landworm_sp, AB_tot == 0 & BM_tot != 0)
# bm_sans_ab[, c("ID","ID_Site", "Programme", "Protocole", "AB_tot", "BM_tot")]

# ab_sans_bm <- subset(landworm_sp, BM_tot == 0 & AB_tot != 0) # 1 parcelles
# ab_sans_bm[, c("ID","ID_Site", "Programme", "Protocole", "AB_tot", "BM_tot")]


# Check des doublons
# 
#duplicated_rows <- subset(landworm_sp, duplicated(landworm_sp[, c("ID", "AB_tot", "BM_tot")]) | #duplicated(landworm_sp[, c("ID", "AB_tot", "BM_tot")], fromLast = TRUE))

```

```{r}
save_landworm = landworm
landworm = landworm_sp
```


```{r fig richness, fig.align='center',fig.height=10}
df_suivi = landworm
n_line = nrow(df_suivi)

df_cleaned = landworm

df_cleaned$Richesse_tot = as.numeric(df_cleaned$Richesse_tot)
explo_num(nom_col = 'Richesse_tot', titre = 'Richesse_tot (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'Richesse_tot', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'Richesse_tot', direction = 'mini')
cat("Sppression des valeurs aberrantes")
explo_num(nom_col = 'Richesse_tot', titre = 'Richesse_tot (after cleaning)', df = df_cleaned)
# summary(df_cleaned$Richesse_tot) 
landworm = df_cleaned
```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

```{r}
df= landworm[landworm$Richesse_tot>12,]
```


**Il n y a pas de valeurs aberant. Cependant, il y a `r nrow(df)` parcelles qui ont une richesse superieur a 12, a garder ou a supprimer ?**

**Details des parcelles a forte richesse (sup à 12): **


```{r}
df= landworm[landworm$Richesse_tot>12,]

# Suppression des observations (lignes) qui ne contiennent que des NA ou des 0
df = df[rowSums(is.na(df) | df == 0) != ncol(df), ]

# Sélection des colonnes qui commencent par "AB_" et qui ont au moins une valeur différente de 0
df = df[, grep("^AB_", colnames(df))]
df = df[, colSums(df != 0, na.rm = TRUE) > 0]

# on elnleve les colonne qui sont dans ab_supprimee
df = df[, !colnames(df) %in% ab_supprimee]
# names(df)

col_ = c("Programme","ID_Site","Annee", "clcm_lvl3", "Richesse_tot")
id = landworm[rownames(df), col_]

dff = cbind(id, df)

rownames(df) = NULL
DT::datatable(dff, options = list(pageLength = 5))

# View(dff)



```






**I remove the `r nrow(dff)` plots with richness greater than 12.**




```{r}
n_line = nrow(landworm)
landworm = landworm[landworm$Richesse_tot<13,]
landworm = droplevels(landworm)

nrow_landW = nrow(landworm)
ncol_landW = ncol(landworm)
# plot(landworm$Richesse_tot)
```
-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


# Branch 1

Saving the database after applying the previous filters.

At this stage, the database has **`r nrow_landW` rows and `r ncol_landW`** columns without the climatic and pedological variables.


```{r}
# all (!duplicated(landworm$ID))
landworm <- landworm %>%
  dplyr::mutate(ID_2 = dplyr::row_number())
# Vérifier si tous les ID_2 sont uniques
# all(!duplicated(landworm$ID_2))
write.xlsx(x =landworm,file = "datas/landworm_bif_1.xlsx" , overwrite = TRUE)
```






# Soil data extraction and adding to landWorm


## The source database

```{r soil source database,echo=FALSE}
chemin_fichier_excel <- "C:/Users/diall/Downloads/datas/ODMAP.xlsx"
pedo <- read.xlsx(chemin_fichier_excel, sheet = "pedo")

# Fusion des cellules des colonnes avec des éléments dupliqués
for (col in names(pedo)) {
  pedo[[col]] <- ifelse(duplicated(pedo[[col]]), "", pedo[[col]])
}

#tableau avec kableExtra et centrage du contenu des cellules
# kableExtra::kable(pedo)

```

<!-- -   Average values between surface (0 cm) and 30 cm depth -->

<p>
  <img src="soils_datas.png">
</p>

## Extraction et fusion

```{r fuion landW et soils_datas, echo=TRUE}
# Ajout variables du soil  (voir script Add_soil_dats.R)
soil_datas <- read.xlsx("datas/soil_datas.xlsx" , sheet = "Sheet 1")
soil_datas <- subset(soil_datas, select = -c(Programme,Annee,Date_Prelevement,ID_Site,gps_x, gps_y))


rows_not_in_soil_datas <- anti_join(landworm, soil_datas, by = "ID_2")
rows_not_in_landworm <- anti_join(soil_datas,landworm, by = "ID_2")

# plot(soil_datas$ID_2, landworm$ID_2)

merged_df <- merge(landworm, soil_datas, by = "ID_2")
ids_not_matching <- anti_join( merged_df,landworm, by = "ID_2")

# colSums(is.na(soil_datas))

nn = nrow(merged_df)

merged_df = drop_na(merged_df,names(soil_datas))

p_sans_pedo = nn - nrow(merged_df)

landworm = merged_df

```

**`r p_sans_pedo` plots have at least one NA in the pedological variables, so I am removing them, and the database goes from `r nn` to `r nrow(landworm)`.**




## Sand

**Extracted values (g/kg, 0 - 30 cm)**

```{r extract sand,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$sable.0_30 = as.numeric(df_cleaned$sable.0_30)
explo_num(nom_col = 'sable.0_30', titre = 'sable.0_30 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'sable.0_30', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'sable.0_30', direction = 'mini')
explo_num(nom_col = 'sable.0_30', titre = 'sable.0_30 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$sable.0_30) 
landworm = df_cleaned

```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.



## Silt

**Extracted values (g/kg, 0 - 30 cm)**

```{r,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$limon.0_30 = as.numeric(df_cleaned$limon.0_30)
explo_num(nom_col = 'limon.0_30', titre = 'limon.0_30 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'limon.0_30', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'limon.0_30', direction = 'mini')
cat("Sppression des valeurs aberrantes")
explo_num(nom_col = 'limon.0_30', titre = 'limon.0_30 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$limon.0_30) 
landworm = df_cleaned

```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## Clay

**Extracted values (g/kg, 0 - 30 cm)**

```{r,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$argile.0_30 = as.numeric(df_cleaned$argile.0_30)
explo_num(nom_col = 'argile.0_30', titre = 'argile.0_30 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'argile.0_30', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'argile.0_30', direction = 'mini')
cat("Sppression des valeurs aberrantes")
explo_num(nom_col = 'argile.0_30', titre = 'argile.0_30 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$argile.0_30) 
landworm = df_cleaned

```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.



## Soil organic carbone (g/kg)

```{r extract C,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$c_orga_0_a_30 = as.numeric(df_cleaned$c_orga_0_a_30)
explo_num(nom_col = 'c_orga_0_a_30', titre = 'c_orga_0_a_30 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'c_orga_0_a_30', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'c_orga_0_a_30', direction = 'mini')
explo_num(nom_col = 'c_orga_0_a_30', titre = 'c_orga_0_a_30 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$c_orga_0_a_30) 
landworm = df_cleaned


```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## pH (H2O)


```{r extract jrc_pH_H2O,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$jrc_pH_H2O = as.numeric(df_cleaned$jrc_pH_H2O)
explo_num(nom_col = 'jrc_pH_H2O', titre = 'jrc_pH_H2O (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'jrc_pH_H2O', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'jrc_pH_H2O', direction = 'mini')
explo_num(nom_col = 'jrc_pH_H2O', titre = 'jrc_pH_H2O (after cleaning)', df = df_cleaned)
# summary(df_cleaned$jrc_pH_H2O) 
landworm = df_cleaned

```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.



## Phosphore (P, mg/kg)

```{r,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$P = as.numeric(df_cleaned$P)
explo_num(nom_col = 'P', titre = 'P (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'P', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'P', direction = 'mini')
cat("Sppression des valeurs aberrantes")
explo_num(nom_col = 'P', titre = 'P (after cleaning)', df = df_cleaned)
# summary(df_cleaned$P) 
landworm = df_cleaned
```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## Azote (N, g/kg)

```{r,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$N = as.numeric(df_cleaned$N)
explo_num(nom_col = 'N', titre = 'N (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'N', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'N', direction = 'mini')
cat("Sppression des valeurs aberrantes")
explo_num(nom_col = 'N', titre = 'N (after cleaning)', df = df_cleaned)
# summary(df_cleaned$N) 
landworm = df_cleaned
```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## Potassium (K, mg/kg)

```{r,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$K = as.numeric(df_cleaned$K)
explo_num(nom_col = 'K', titre = 'K (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'K', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'K', direction = 'mini')
explo_num(nom_col = 'K', titre = 'K (after cleaning)', df = df_cleaned)
# summary(df_cleaned$N) 
landworm = df_cleaned
```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## C/N

```{r,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$CN = as.numeric(df_cleaned$CN)
explo_num(nom_col = 'CN', titre = 'CN (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'CN', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'CN', direction = 'mini')
explo_num(nom_col = 'CN', titre = 'CN (after cleaning)', df = df_cleaned)
# summary(df_cleaned$N) 
landworm = df_cleaned
```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## Carbonates de calcium (CaCO3, g/kg)

```{r,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$CaCO3 = as.numeric(df_cleaned$CaCO3)
explo_num(nom_col = 'CaCO3', titre = 'CaCO3 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'CaCO3', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'CaCO3', direction = 'mini')
cat("Sppression des valeurs aberrantes")
explo_num(nom_col = 'CaCO3', titre = 'CaCO3 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$N) 
landworm = df_cleaned
```

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.









# Climate data extraction and adding to landWorm

```{r}
Predictors_f = c("CaCO3" ,"gps_x" ,"N" ,"tasmax" ,"gps_y" ,"clay" ,
                 "silt" ,"clcm_lvl3" ,"P" ,"bio12" )
```

## The source database ([CHELSA V2](https://chelsa-climate.org/timeseries/){target="_blank"})

```{r Climate df extraction,echo=TRUE}

# Lire le fichier Excel
chemin_fichier_excel <- "C:/Users/diall/Downloads/datas/ODMAP.xlsx"
climat <- read.xlsx(chemin_fichier_excel, sheet = "climat")

# Fusions des cellules des colonnes avec des éléments dupliqués
for (col in names(climat)) {
  climat[[col]] <- ifelse(duplicated(climat[[col]]), "", climat[[col]])
}

# Affichage du tableau avec kableExtra et centrage du contenu des cellules
# kableExtra::kable(climat)

```

For each of the following variables, I calculate the **mean** and the **standard deviation** at **3 months**, **6 months**, and **120 months** (30 variables in total). 


<p>
  <img src="climate_datas.png">
</p>


**Data available only until 2018/2019**.


## Extraction method

See file [Script 1 DownloadChelsaData](C:/Users/diall/Downloads/datas/0_DownloadChelsaData.r){target="_blank"}

See file [Script 2 AddchelsaData](C:/Users/diall/Downloads/datas/2_AddChelsaData.R){target="_blank"}
 

**Steps:**

1. **Obtain a vector of "month_Year" periods**:
   - Extract the unique periods (month_year).

2. **Initialize the necessary columns**:
   - Define the periods of interest ("3_months", "6_months", "120_months").
   - Define the variables of interest ("pet", "pr", "tas", "tasmax", "tasmin").
   - Initialize columns for means and standard deviations for each period and each variable.

3. **Main loop through periods and variables**:
   - Iterate over each variable of interest.
   - Iterate over each "month_Year" period.
     - Load the rasters corresponding to the 120-month period.
     - Extract raster data for the specified GPS points.
     - Convert units according to the variable.
     - Select sub-periods of 3, 6, and 120 months.
     - Calculate means and standard deviations for each period.

4. **Save the updated data**

   

5. **Merging database and climat database**


```{r mergins & climat, echo=TRUE }
# Ajout variables du climate  (voir script Add_climate_dats.R)
climate_datas <- read.xlsx("datas/climate_datas.xlsx" , sheet = "Sheet 1")
climate_datas <- subset(climate_datas, select = -c(Programme,Annee,Date_Prelevement,ID_Site,gps_x, gps_y))


rows_not_in_climate_datas <- anti_join(landworm, climate_datas, by = "ID_2")
rows_not_in_landworm <- anti_join(climate_datas,landworm, by = "ID_2")

# plot(climate_datas$ID_2, landworm$ID_2)

merged_df <- merge(landworm, climate_datas, by = "ID_2")
ids_not_matching <- anti_join( merged_df,landworm, by = "ID_2")

# colSums(is.na(climate_datas))

nn = nrow(merged_df)

merged_df = drop_na(merged_df,names(climate_datas))

p_sans_climat = nn - nrow(merged_df)

landworm = merged_df

```

**`r p_sans_climat` plots have at least one NA in the climate variables, so I am removing them, and the database goes from `r nn` to `r nrow(landworm)`.**





## Average annual air temperature (°C) = tas


::: {.panel-tabset}

## 1. At 3 months

    
-   **Mean**

```{r extract tas_mean_3,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tas_mean_3 = as.numeric(df_cleaned$tas_mean_3)
explo_num(nom_col = 'tas_mean_3', titre = 'tas_mean_3 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tas_mean_3', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tas_mean_3', direction = 'mini')
explo_num(nom_col = 'tas_mean_3', titre = 'tas_mean_3 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tas_mean_3) 
landworm = df_cleaned
```    

The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    
-   **Standard deviation**
    
```{r extract tas_sd_3,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tas_sd_3 = as.numeric(df_cleaned$tas_sd_3)
explo_num(nom_col = 'tas_sd_3', titre = 'tas_sd_3 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tas_sd_3', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tas_sd_3', direction = 'mini')
explo_num(nom_col = 'tas_sd_3', titre = 'tas_sd_3 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tas_sd_3) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## 2. At 6 months

    
-   **Mean**
    
    
```{r extract tas_mean_6,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tas_mean_6 = as.numeric(df_cleaned$tas_mean_6)
explo_num(nom_col = 'tas_mean_6', titre = 'tas_mean_6 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tas_mean_6', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tas_mean_6', direction = 'mini')
explo_num(nom_col = 'tas_mean_6', titre = 'tas_mean_6 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tas_mean_6) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

  
-   **Standard deviation**
    
```{r extract tas_sd_6,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tas_sd_6 = as.numeric(df_cleaned$tas_sd_6)
explo_num(nom_col = 'tas_sd_6', titre = 'tas_sd_6 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tas_sd_6', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tas_sd_6', direction = 'mini')
explo_num(nom_col = 'tas_sd_6', titre = 'tas_sd_6 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tas_sd_6) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    

## 3. At 120 months

    
-   **Mean**
    
    
```{r extract tas_mean_120,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tas_mean_120 = as.numeric(df_cleaned$tas_mean_120)
explo_num(nom_col = 'tas_mean_120', titre = 'tas_mean_120 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tas_mean_120', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tas_mean_120', direction = 'mini')
explo_num(nom_col = 'tas_mean_120', titre = 'tas_mean_120 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tas_mean_120) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    
-   **Standard deviation**
    
```{r extract tas_sd_120,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tas_sd_120 = as.numeric(df_cleaned$tas_sd_120)
explo_num(nom_col = 'tas_sd_120', titre = 'tas_sd_120 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tas_sd_120', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tas_sd_120', direction = 'mini')
explo_num(nom_col = 'tas_sd_120', titre = 'tas_sd_120 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tas_sd_120) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

:::
  
  


## Mean daily maximum 2m air temperature (°C) = tasmax 

::: {.panel-tabset}

## 1. At 3 months

    
-   **Mean**

```{r extract tasmax_mean_3,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tasmax_mean_3 = as.numeric(df_cleaned$tasmax_mean_3)
explo_num(nom_col = 'tasmax_mean_3', titre = 'tasmax_mean_3 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tasmax_mean_3', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tasmax_mean_3', direction = 'mini')
explo_num(nom_col = 'tasmax_mean_3', titre = 'tasmax_mean_3 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tasmax_mean_3) 
landworm = df_cleaned
```    

The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    
-   **Standard deviation**
    
```{r extract tasmax_sd_3,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tasmax_sd_3 = as.numeric(df_cleaned$tasmax_sd_3)
explo_num(nom_col = 'tasmax_sd_3', titre = 'tasmax_sd_3 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tasmax_sd_3', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tasmax_sd_3', direction = 'mini')
explo_num(nom_col = 'tasmax_sd_3', titre = 'tasmax_sd_3 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tasmax_sd_3) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## 2. At 6 months

    
-   **Mean**
    
    
```{r extract tasmax_mean_6,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tasmax_mean_6 = as.numeric(df_cleaned$tasmax_mean_6)
explo_num(nom_col = 'tasmax_mean_6', titre = 'tasmax_mean_6 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tasmax_mean_6', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tasmax_mean_6', direction = 'mini')
explo_num(nom_col = 'tasmax_mean_6', titre = 'tasmax_mean_6 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tasmax_mean_6) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

  
-   **Standard deviation**
    
```{r extract tasmax_sd_6,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tasmax_sd_6 = as.numeric(df_cleaned$tasmax_sd_6)
explo_num(nom_col = 'tasmax_sd_6', titre = 'tasmax_sd_6 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tasmax_sd_6', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tasmax_sd_6', direction = 'mini')
explo_num(nom_col = 'tasmax_sd_6', titre = 'tasmax_sd_6 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tasmax_sd_6) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    

## 3. At 120 months

    
-   **Mean**
    
    
```{r extract tasmax_mean_120,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tasmax_mean_120 = as.numeric(df_cleaned$tasmax_mean_120)
explo_num(nom_col = 'tasmax_mean_120', titre = 'tasmax_mean_120 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tasmax_mean_120', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tasmax_mean_120', direction = 'mini')
explo_num(nom_col = 'tasmax_mean_120', titre = 'tasmax_mean_120 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tasmax_mean_120) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    
-   **Standard deviation**
    
```{r extract tasmax_sd_120,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tasmax_sd_120 = as.numeric(df_cleaned$tasmax_sd_120)
explo_num(nom_col = 'tasmax_sd_120', titre = 'tasmax_sd_120 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tasmax_sd_120', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tasmax_sd_120', direction = 'mini')
explo_num(nom_col = 'tasmax_sd_120', titre = 'tasmax_sd_120 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tasmax_sd_120) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

:::


## Mean daily maximum 2m air temperature (°C) = tasmin 

::: {.panel-tabset}

## 1. At 3 months

    
-   **Mean**

```{r extract tasmin_mean_3,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tasmin_mean_3 = as.numeric(df_cleaned$tasmin_mean_3)
explo_num(nom_col = 'tasmin_mean_3', titre = 'tasmin_mean_3 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tasmin_mean_3', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tasmin_mean_3', direction = 'mini')
explo_num(nom_col = 'tasmin_mean_3', titre = 'tasmin_mean_3 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tasmin_mean_3) 
landworm = df_cleaned
```    

The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    
-   **Standard deviation**
    
```{r extract tasmin_sd_3,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tasmin_sd_3 = as.numeric(df_cleaned$tasmin_sd_3)
explo_num(nom_col = 'tasmin_sd_3', titre = 'tasmin_sd_3 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tasmin_sd_3', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tasmin_sd_3', direction = 'mini')
explo_num(nom_col = 'tasmin_sd_3', titre = 'tasmin_sd_3 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tasmin_sd_3) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## 2. At 6 months

    
-   **Mean**
    
    
```{r extract tasmin_mean_6,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tasmin_mean_6 = as.numeric(df_cleaned$tasmin_mean_6)
explo_num(nom_col = 'tasmin_mean_6', titre = 'tasmin_mean_6 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tasmin_mean_6', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tasmin_mean_6', direction = 'mini')
explo_num(nom_col = 'tasmin_mean_6', titre = 'tasmin_mean_6 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tasmin_mean_6) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

  
-   **Standard deviation**
    
```{r extract tasmin_sd_6,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tasmin_sd_6 = as.numeric(df_cleaned$tasmin_sd_6)
explo_num(nom_col = 'tasmin_sd_6', titre = 'tasmin_sd_6 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tasmin_sd_6', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tasmin_sd_6', direction = 'mini')
explo_num(nom_col = 'tasmin_sd_6', titre = 'tasmin_sd_6 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tasmin_sd_6) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    

## 3. At 120 months

    
-   **Mean**
    
    
```{r extract tasmin_mean_120,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tasmin_mean_120 = as.numeric(df_cleaned$tasmin_mean_120)
explo_num(nom_col = 'tasmin_mean_120', titre = 'tasmin_mean_120 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tasmin_mean_120', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tasmin_mean_120', direction = 'mini')
explo_num(nom_col = 'tasmin_mean_120', titre = 'tasmin_mean_120 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tasmin_mean_120) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    
-   **Standard deviation**
    
```{r extract tasmin_sd_120,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$tasmin_sd_120 = as.numeric(df_cleaned$tasmin_sd_120)
explo_num(nom_col = 'tasmin_sd_120', titre = 'tasmin_sd_120 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'tasmin_sd_120', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'tasmin_sd_120', direction = 'mini')
explo_num(nom_col = 'tasmin_sd_120', titre = 'tasmin_sd_120 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$tasmin_sd_120) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

:::

## Annual precipitation (mm/month) = pr


::: {.panel-tabset}

## 1. At 3 months

    
-   **Mean**

```{r extract pr_mean_3,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$pr_mean_3 = as.numeric(df_cleaned$pr_mean_3)
explo_num(nom_col = 'pr_mean_3', titre = 'pr_mean_3 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'pr_mean_3', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'pr_mean_3', direction = 'mini')
explo_num(nom_col = 'pr_mean_3', titre = 'pr_mean_3 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$pr_mean_3) 
landworm = df_cleaned
```    

The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    
-   **Standard deviation**
    
```{r extract pr_sd_3,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$pr_sd_3 = as.numeric(df_cleaned$pr_sd_3)
explo_num(nom_col = 'pr_sd_3', titre = 'pr_sd_3 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'pr_sd_3', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'pr_sd_3', direction = 'mini')
explo_num(nom_col = 'pr_sd_3', titre = 'pr_sd_3 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$pr_sd_3) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## 2. At 6 months

    
-   **Mean**
    
    
```{r extract pr_mean_6,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$pr_mean_6 = as.numeric(df_cleaned$pr_mean_6)
explo_num(nom_col = 'pr_mean_6', titre = 'pr_mean_6 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'pr_mean_6', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'pr_mean_6', direction = 'mini')
explo_num(nom_col = 'pr_mean_6', titre = 'pr_mean_6 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$pr_mean_6) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

  
-   **Standard deviation**
    
```{r extract pr_sd_6,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$pr_sd_6 = as.numeric(df_cleaned$pr_sd_6)
explo_num(nom_col = 'pr_sd_6', titre = 'pr_sd_6 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'pr_sd_6', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'pr_sd_6', direction = 'mini')
explo_num(nom_col = 'pr_sd_6', titre = 'pr_sd_6 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$pr_sd_6) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    

## 3. At 120 months

    
-   **Mean**
    
    
```{r extract pr_mean_120,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$pr_mean_120 = as.numeric(df_cleaned$pr_mean_120)
explo_num(nom_col = 'pr_mean_120', titre = 'pr_mean_120 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'pr_mean_120', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'pr_mean_120', direction = 'mini')
explo_num(nom_col = 'pr_mean_120', titre = 'pr_mean_120 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$pr_mean_120) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    
-   **Standard deviation**
    
```{r extract pr_sd_120,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$pr_sd_120 = as.numeric(df_cleaned$pr_sd_120)
explo_num(nom_col = 'pr_sd_120', titre = 'pr_sd_120 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'pr_sd_120', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'pr_sd_120', direction = 'mini')
explo_num(nom_col = 'pr_sd_120', titre = 'pr_sd_120 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$pr_sd_120) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

:::

## Potential evapotranspiration (mm/month) => pet


::: {.panel-tabset}

## 1. At 3 months

    
-   **Mean**

```{r extract pet_mean_3,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$pet_mean_3 = as.numeric(df_cleaned$pet_mean_3)
explo_num(nom_col = 'pet_mean_3', titre = 'pet_mean_3 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'pet_mean_3', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'pet_mean_3', direction = 'mini')
explo_num(nom_col = 'pet_mean_3', titre = 'pet_mean_3 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$pet_mean_3) 
landworm = df_cleaned
```    

The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    
-   **Standard deviation**
    
```{r extract pet_sd_3,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$pet_sd_3 = as.numeric(df_cleaned$pet_sd_3)
explo_num(nom_col = 'pet_sd_3', titre = 'pet_sd_3 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'pet_sd_3', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'pet_sd_3', direction = 'mini')
explo_num(nom_col = 'pet_sd_3', titre = 'pet_sd_3 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$pet_sd_3) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.


## 2. At 6 months

    
-   **Mean**
    
    
```{r extract pet_mean_6,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$pet_mean_6 = as.numeric(df_cleaned$pet_mean_6)
explo_num(nom_col = 'pet_mean_6', titre = 'pet_mean_6 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'pet_mean_6', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'pet_mean_6', direction = 'mini')
explo_num(nom_col = 'pet_mean_6', titre = 'pet_mean_6 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$pet_mean_6) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

  
-   **Standard deviation**
    
```{r extract pet_sd_6,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$pet_sd_6 = as.numeric(df_cleaned$pet_sd_6)
explo_num(nom_col = 'pet_sd_6', titre = 'pet_sd_6 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'pet_sd_6', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'pet_sd_6', direction = 'mini')
explo_num(nom_col = 'pet_sd_6', titre = 'pet_sd_6 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$pet_sd_6) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    

## 3. At 120 months

    
-   **Mean**
    
    
```{r extract pet_mean_120,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$pet_mean_120 = as.numeric(df_cleaned$pet_mean_120)
explo_num(nom_col = 'pet_mean_120', titre = 'pet_mean_120 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'pet_mean_120', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'pet_mean_120', direction = 'mini')
explo_num(nom_col = 'pet_mean_120', titre = 'pet_mean_120 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$pet_mean_120) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

    
-   **Standard deviation**
    
```{r extract pet_sd_120,fig.align='center',fig.height=8}
n_line = nrow(landworm)

df_cleaned = landworm

df_cleaned$pet_sd_120 = as.numeric(df_cleaned$pet_sd_120)
explo_num(nom_col = 'pet_sd_120', titre = 'pet_sd_120 (before cleaning)', df = df_cleaned)
df_cleaned <- test_grub(df_cleaned, 'pet_sd_120', direction = 'maxi')
df_cleaned <- test_grub(df_cleaned, 'pet_sd_120', direction = 'mini')
explo_num(nom_col = 'pet_sd_120', titre = 'pet_sd_120 (after cleaning)', df = df_cleaned)
# summary(df_cleaned$pet_sd_120) 
landworm = df_cleaned
```    

-   The database therefore changes from **`r n_line`** to **`r nrow(landworm)`** observations.

:::









# Exploratory analysis

**Data set reduction:**

- 3 Response variables: Abundance, biomass, and richness

- 41 Explanatory variables (including 30 climatic, 10 pedological, and land use)



```{r ana,echo=TRUE,fig.height=8,fig.show='animate',fig.align='center'}
id_col=c("ID_2","Programme","Annee","ID_Site","Protocole")

vdt_col=c("AB_tot", "BM_tot", "Richesse_tot")

os_and_gps = c('clcm_lvl3','gps_x', 'gps_y')

soils_variables = c("sable.0_30","limon.0_30","argile.0_30",'jrc_pH_H2O','N','P','K','CN', 'CaCO3',"c_orga_0_a_30")

climates_variables = c("tas_mean_3","tas_mean_6","tas_mean_120",
                      "tas_sd_3","tas_sd_6","tas_sd_120",
                      
                      "tasmax_mean_3","tasmax_mean_6","tasmax_mean_120",
                      "tasmax_sd_3","tasmax_sd_6","tasmax_sd_120",
                      
                      "tasmin_mean_3","tasmin_mean_6","tasmin_mean_120",
                      "tasmin_sd_3","tasmin_sd_6","tasmin_sd_120",
                      
                      "pr_mean_3","pr_mean_6","pr_mean_120",
                      "pr_sd_3","pr_sd_6","pr_sd_120",
                      
                      "pet_mean_3","pet_mean_6","pet_mean_120",
                      "pet_sd_3","pet_sd_6","pet_sd_120")

landworm_explo = landworm[,c(id_col,vdt_col,os_and_gps,soils_variables,climates_variables)]

landworm_explo <- landworm_explo %>%
  dplyr::rename(
    Sand = sable.0_30,
    Silt = limon.0_30,
    Clay = argile.0_30,
    pH = jrc_pH_H2O,
    C_org = c_orga_0_a_30,
    LC_ = clcm_lvl3,
    Long = gps_x ,
    Lat =  gps_y
  )



cl_original <- levels(landworm_explo$LC_)
new_cl <- c("For","Gua", "Nag", "Nial", "Pmo", "Viny")
landworm_explo$LC_ <- factor(landworm_explo$LC_, levels = cl_original, labels = new_cl)



soils_variables = c("Sand","Silt","Clay",'pH','N','P','K','CN', 'CaCO3',"C_org")
variables_factor = c("LC_")
all_predictors = c(variables_factor,soils_variables,climates_variables)

all_predictors_num = all_predictors[!all_predictors %in% c(variables_factor)]


```

```{r}
write.csv(x =landworm_explo,file = "datas/landworm_explo.csv", row.names = FALSE)

write.xlsx(x =landworm_explo,file = "datas/landworm_explo.xlsx", overwrite = TRUE)
```

**Il reste donc `r nrow(landworm_explo)` lignes et `r ncol(landworm_explo)` colonnes. **


##  Correlation matrix

-   **All predictors**

```{r , fig.height=8}
#| column: screen
#| out-width: 100%

#calculate correlation coefficients, rounded to 2 decimal places
df = landworm_explo[,all_predictors_num]
cor_df <- round(cor(df), 2)

#reshape2::melt the data frame
melted_cor <- reshape2::melt(cor_df)

#create correlation heatmap
p = ggplot(data = melted_cor, aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile() +
  geom_text(aes(label = round(value, 2)), size = 2) +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), name = "Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8))

# p <- ggplotly(p)
p
```



-   **Correlation < |0.07| = 0**

```{r, fig.height=8}
#| column: screen
#| out-width: 100%


#calculate correlation coefficients, rounded to 2 decimal places
df = landworm_explo[,all_predictors_num]
cor_df <- round(cor(df), 2)

cor_df[abs(cor_df) < 0.7] <- 0
#reshape2::melt the data frame
melted_cor <- reshape2::melt(cor_df)

#create correlation heatmap
p = ggplot(data = melted_cor, aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile() +
  geom_text(aes(label = round(value, 2)), size = 2) +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), name = "Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8))
# p <- ggplotly(p)
p

```

**Séparation entre les variables pédologiques et climatiques**

**a). Variables pédologiques** 

```{r , fig.height=8}
#| column: screen
#| out-width: 100%

#calculate correlation coefficients, rounded to 2 decimal places
df = landworm_explo[,soils_variables]
cor_df <- round(cor(df), 2)

cor_df[abs(cor_df) < 0.7] <- 0
#reshape2::melt the data frame
melted_cor <- reshape2::melt(cor_df)
#create correlation heatmap
p = ggplot(data = melted_cor, aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile() +
  geom_text(aes(label = round(value, 2)), size = 2) +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), name = "Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8))
# p <- ggplotly(p)
p
```

```{r}
deleted_1 = c("Silt", "CaCO3")
```

Conclusion: je supprime **Silt** et je garde **Sand**. De même je suprime **CaCO3** et je garde **pH**.


**b). Variables climatiques:** 

```{r , fig.height=8}
#| column: screen
#| out-width: 100%

#calculate correlation coefficients, rounded to 2 decimal places
climates_variables_2 = climates_variables

df = landworm_explo[,climates_variables_2]
cor_df <- round(cor(df), 2)

cor_df[abs(cor_df) < 0.7] <- 0
#reshape2::melt the data frame
melted_cor <- reshape2::melt(cor_df)
#create correlation heatmap
p = ggplot(data = melted_cor, aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile() +
  geom_text(aes(label = round(value, 2)), size = 2) +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), name = "Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8))
# p <- ggplotly(p)
p
```

```{r}
deleted_2 = c("pet_sd_120", "pet_sd_3", "pr_sd_120", "pr_sd_6", "tasmin_sd_120", "tasmin_sd_6", "tasmin_sd_3","tasmax_sd_120", "tasmax_sd_6", "tasmax_sd_3")
```

**On enlève d'abord les variables sd**:

`r deleted_2`


```{r , fig.height=8}
#| column: screen
#| out-width: 100%

#calculate correlation coefficients, rounded to 2 decimal places
climates_variables_2 = climates_variables
climates_variables_2 = climates_variables_2[!climates_variables_2 %in% deleted_2]

df = landworm_explo[,climates_variables_2]
cor_df <- round(cor(df), 2)

cor_df[abs(cor_df) < 0.7] <- 0
#reshape2::melt the data frame
melted_cor <- reshape2::melt(cor_df)
#create correlation heatmap
p = ggplot(data = melted_cor, aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile() +
  geom_text(aes(label = round(value, 2)), size = 2) +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), name = "Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8))
# p <- ggplotly(p)
p
```

```{r}
deleted_3 = c("pet_mean_3","pet_mean_120","tas_mean_3","tasmin_mean_3","tasmin_mean_6","tasmin_mean_120","tasmax_mean_6", "tasmax_mean_3",  "tasmax_mean_120", "pr_mean_6")
```

**Maintenat on enleve les variables qui ont le plus de correlation**

**On enleve donc**:

`r deleted_3`


```{r , fig.height=8}
#| column: screen
#| out-width: 100%

#calculate correlation coefficients, rounded to 2 decimal places
climates_variables_3 = climates_variables_2
climates_variables_3 = climates_variables_3[!climates_variables_3 %in% deleted_3]

df = landworm_explo[,climates_variables_3]
cor_df <- round(cor(df), 2)

cor_df[abs(cor_df) < 0.7] <- 0
#reshape2::melt the data frame
melted_cor <- reshape2::melt(cor_df)
#create correlation heatmap
p = ggplot(data = melted_cor, aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile() +
  geom_text(aes(label = round(value, 2)), size = 2) +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), name = "Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8))
# p <- ggplotly(p)
p
```


**Synthese**

```{r}
deleted_variables = c(deleted_1, deleted_2,deleted_3)
predictor_non_r = all_predictors_num[!all_predictors_num %in% deleted_variables]
```

```{r , fig.height=8}
#| column: screen
#| out-width: 100%


df = landworm_explo[,predictor_non_r]
cor_df <- round(cor(df), 2)

# cor_df[abs(cor_df) < 0.7] <- 0
#reshape2::melt the data frame
melted_cor <- reshape2::melt(cor_df)
#create correlation heatmap
p = ggplot(data = melted_cor, aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile() +
  geom_text(aes(label = round(value, 2)), size = 2) +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), name = "Correlation") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8))
# p <- ggplotly(p)
p
```

**Il reste donc `r length(predictor_non_r)` variables explicatives non correlee**

=> `r length(deleted_variables)` variables supprimees
  



##  VIF
```{r, fig.align='center',fig.dpi=300}
# usdm::vif(landworm_explo[,all_predictors_num])
# usdm::vifcor(landworm_explo[,all_predictors_num], th = 0.7, keep = NULL, method = 'pearson')
usdm::vifstep(landworm_explo[,predictor_non_r], th = 10, keep = NULL, method = 'pearson')
```




## Relationship between the abundance and the predictors 

```{r cor_AB_tot}
# Creation d'un df des correlation entre var_rep et les variables explicatives (all_predictors_num)
var_rep= "AB_tot"

correlations <- sapply(all_predictors_num, function(var) {
  cor(landworm_explo[[var_rep]], landworm_explo[[var]], use = "complete.obs")
})

correlation_df <- data.frame(
  Variables = all_predictors_num,
  Correlations = round (correlations,4)
)
rownames(correlation_df) = NULL
datatable(correlation_df, options = list(pageLength = 5))
```


```{r plot_AB_tot,fig.align='center',fig.height=4,fig.width=4,fig.dpi=150}
var_rep <- 'AB_tot'
titre <- paste('AB_tot & LC_')
cat(paste0("- ",titre,"\n"))

box_plot(df = landworm_explo, var_rep = var_rep, predicteur = 'LC_', titre_x = 'LC_', titre_y = var_rep)

for (i in 1:length(all_predictors_num)) {
  cat(paste('- ', var_rep, '&', all_predictors_num[i]))
  g <- nuage_point(df = landworm_explo,
                    var_rep = var_rep,
                    predicteur = all_predictors_num[i],
                    titre_x = all_predictors_num[i],
                    titre_y = var_rep)
  print(g)
}
```


## Relationship between the biomass and the predictors 

```{r cor_BM_tot}
# Creation d'un df des correlation entre var_rep et les variables explicatives (all_predictors_num)
var_rep= "BM_tot"

correlations <- sapply(all_predictors_num, function(var) {
  cor(landworm_explo[[var_rep]], landworm_explo[[var]], use = "complete.obs")
})

correlation_df <- data.frame(
  Variables = all_predictors_num,
  Correlations = round (correlations,4)
)
rownames(correlation_df) = NULL
datatable(correlation_df, options = list(pageLength = 5))
```


```{r plot_BM_tot,fig.align='center',fig.height=4,fig.width=4,fig.dpi=150}
var_rep <- 'BM_tot'
titre <- paste('BM_tot & LC_')
cat(paste0("- ",titre,"\n"))

box_plot(df = landworm_explo, var_rep = var_rep, predicteur = 'LC_', titre_x = 'LC_', titre_y = var_rep)

for (i in 1:length(all_predictors_num)) {
  cat(paste('- ', var_rep, '&', all_predictors_num[i]))
  g <- nuage_point(df = landworm_explo,
                    var_rep = var_rep,
                    predicteur = all_predictors_num[i],
                    titre_x = all_predictors_num[i],
                    titre_y = var_rep)
  print(g)
}
```



## Relationship between the richness and the predictors 

```{r cor_Richesse_tot}
# Creation d'un df des correlation entre var_rep et les variables explicatives (all_predictors_num)
var_rep= "Richesse_tot"

correlations <- sapply(all_predictors_num, function(var) {
  cor(landworm_explo[[var_rep]], landworm_explo[[var]], use = "complete.obs")
})

correlation_df <- data.frame(
  Variables = all_predictors_num,
  Correlations = round (correlations,4)
)
rownames(correlation_df) = NULL
datatable(correlation_df, options = list(pageLength = 5))
```

```{r plot_Richesse , fig.align='center', fig.height=4, fig.width=4, fig.dpi=150}
var_rep <- 'Richesse_tot'
titre <- paste('Richesse_tot & LC_')
cat(paste0("- ",titre,"\n"))

box_plot(df = landworm_explo, var_rep = var_rep, predicteur = 'LC_', titre_x = 'LC_', titre_y = var_rep)

# titre <- paste('AB_tot & Fertilisation')
# cat(paste0("- ",titre,"\n"))
# box_plot(df = landworm_explo, var_rep = var_rep, predicteur = 'Fertilisation', titre_x = 'Fertilisation', titre_y = var_rep)
# 
# titre <- paste('AB_tot & Travail_du_sol')
# cat(paste0("- ",titre,"\n"))
# box_plot(df = landworm_explo, var_rep = var_rep, predicteur = 'Travail_du_sol', titre_x = 'Travail_du_sol', titre_y = var_rep)

for (i in 1:length(all_predictors_num)) {
  cat(paste('- ', var_rep, '&', all_predictors_num[i]))
  g <- nuage_point(df = landworm_explo,
                    var_rep = var_rep,
                    predicteur = all_predictors_num[i],
                    titre_x = all_predictors_num[i],
                    titre_y = var_rep)
  print(g)
}
```



## Total abundance distributions

```{r abundance dist,fig.align='center',fig.height=4,fig.width=4}
df <- data.frame(y =landworm_explo$AB_tot)
# Test de Shapiro-Wilk
AB_tot_test_nor = shapiro.test(df$y)
AB_tot_p.value =round(AB_tot_test_nor$p.value,3)
 if(AB_tot_p.value ==0){
   AB_tot_p.value = "; p.value > 0.001"
 } else {
   AB_tot_p.value = paste0("; p.value = ",AB_tot_p.value)   
 }
AB_tot_sub = paste0("Shapiro-Wilk; W = ",round(AB_tot_test_nor$statistic,2),AB_tot_p.value)

```



::: columns
::: {.column width="50%"}

<p>
  <img src="lamda_boxcox.png">
</p>

<br/>
```{r}
# Histogramme
ggplot(df, aes(x=y)) +
geom_histogram( fill="#69b3a2", color="#e9ecef", bins=30, alpha=2) +
  geom_density(fill="black", alpha=0.2) +
  theme_gray() +
  labs(title="Abundance", subtitle =AB_tot_sub, x="Value", y="Density") +
  theme(plot.title = element_text(hjust = 0.5))
```


-   Transformation sqrt
```{r ,fig.dpi=300,fig.align='center',fig.height=4,fig.width=4}
df_2 <- data.frame(y =sqrt(landworm_explo$AB_tot))
# Test de Shapiro-Wilk
AB_tot_test_nor = shapiro.test(df_2$y)
AB_tot_p.value =round(AB_tot_test_nor$p.value,3)
 if(AB_tot_p.value ==0){
   AB_tot_p.value = "; p.value > 0.001"
 } else {
   AB_tot_p.value = paste0("; p.value = ",AB_tot_p.value)   
 }
AB_tot_sub = paste0("Shapiro-Wilk; W = ",round(AB_tot_test_nor$statistic,2),AB_tot_p.value)

```

```{r}
# Histogramme
ggplot(df_2, aes(x=y)) +
geom_histogram( fill="#69b3a2", color="#e9ecef", bins=30, alpha=2) +
  geom_density(fill="black", alpha=0.2) +
  theme_gray() +
  labs(title="Abundance", subtitle =AB_tot_sub, x="Value", y="Density") +
  theme(plot.title = element_text(hjust = 0.5))

```
:::

::: {.column width="50%"}
```{r}
# https://r-coder.com/box-cox-transformation-r/?utm_content=cmp-true
# landworm_explo$AB_tot[landworm_explo$AB_tot < 0]
x = as.numeric ( landworm_explo$AB_tot )+1


b <- MASS::boxcox(lm(x ~ 1),plotit = FALSE) # ou bestNormalize

# Exact lambda
lambda1 <- b$x[which.max(b$y)]

MASS::boxcox(lm(x ~ 1),plotit = TRUE)


```
    lamda = `r lambda1`

<br/> 

```{r}
# QQ-plot
qqnorm(df$y)
qqline(df$y)
```

<br/> 
<br/> 
```{r}

# QQ-plot
qqnorm(df_2$y)
qqline(df_2$y)
```

:::
:::



## Total biomass distributions

```{r biomass dist,fig.align='center',fig.height=4,fig.width=4}
df <- data.frame(y =landworm_explo$BM_tot)
# Test de Shapiro-Wilk
BM_tot_test_nor = shapiro.test(df$y)
BM_tot_p.value =round(BM_tot_test_nor$p.value,3)
 if(BM_tot_p.value ==0){
   BM_tot_p.value = "; p.value > 0.001"
 } else {
   BM_tot_p.value = paste0("; p.value = ",BM_tot_p.value)   
 }
BM_tot_sub = paste0("Shapiro-Wilk; W = ",round(BM_tot_test_nor$statistic,2),BM_tot_p.value)

```


::: columns
::: {.column width="50%"}

<p>
  <img src="lamda_boxcox.png">
</p>

<br/>
```{r}
# Histogramme
ggplot(df, aes(x=y)) +
geom_histogram( fill="#69b3a2", color="#e9ecef", bins=30, alpha=2) +
  geom_density(fill="black", alpha=0.2) +
  theme_gray() +
  labs(title="biomass", subtitle =BM_tot_sub, x="Value", y="Density") +
  theme(plot.title = element_text(hjust = 0.5))
```

-   Transformation sqrt
```{r ,fig.dpi=300,fig.align='center',fig.height=4,fig.width=4}
df_2 <- data.frame(y =sqrt(landworm_explo$BM_tot))
# Test de Shapiro-Wilk
BM_tot_test_nor = shapiro.test(df_2$y)
BM_tot_p.value =round(BM_tot_test_nor$p.value,3)
 if(BM_tot_p.value ==0){
   BM_tot_p.value = "; p.value > 0.001"
 } else {
   BM_tot_p.value = paste0("; p.value = ",BM_tot_p.value)   
 }
BM_tot_sub = paste0("Shapiro-Wilk; W = ",round(BM_tot_test_nor$statistic,2),BM_tot_p.value)

```

```{r}
# Histogramme
ggplot(df_2, aes(x=y)) +
geom_histogram( fill="#69b3a2", color="#e9ecef", bins=30, alpha=2) +
  geom_density(fill="black", alpha=0.2) +
  theme_gray() +
  labs(title="biomass", subtitle =BM_tot_sub, x="Value", y="Density") +
  theme(plot.title = element_text(hjust = 0.5))

```
:::

::: {.column width="50%"}
```{r}
# https://r-coder.com/box-cox-transformation-r/?utm_content=cmp-true
# landworm_explo$BM_tot[landworm_explo$BM_tot < 0]
x = as.numeric ( landworm_explo$BM_tot )+1


b <- MASS::boxcox(lm(x ~ 1),plotit = FALSE)

# Exact lambda
lambda <- b$x[which.max(b$y)]

lambda = round(lambda,3)
MASS::boxcox(lm(x ~ 1),plotit = TRUE)


```
    lamda = `r lambda`

<br/> 

```{r}
# QQ-plot
qqnorm(df$y)
qqline(df$y)
```

<br/> 
<br/> 
```{r}

# QQ-plot
qqnorm(df_2$y)
qqline(df_2$y)
```

:::
:::



## Total taxonomic richness distributions

```{r richness dist,fig.align='center',fig.height=4,fig.width=4}
df <- data.frame(y =landworm_explo$Richesse_tot)
# Test de Shapiro-Wilk
Richesse_tot_test_nor = shapiro.test(df$y)
Richesse_tot_p.value =round(Richesse_tot_test_nor$p.value,3)
 if(Richesse_tot_p.value ==0){
   Richesse_tot_p.value = "; p.value > 0.001"
 } else {
   Richesse_tot_p.value = paste0("; p.value = ",Richesse_tot_p.value)   
 }
Richesse_tot_sub = paste0("Shapiro-Wilk; W = ",round(Richesse_tot_test_nor$statistic,2),Richesse_tot_p.value)

```



::: columns
::: {.column width="50%"}

<p>
  <img src="lamda_boxcox.png">
</p>

<br/>

```{r}
# Histogramme
ggplot(df, aes(x=y)) +
geom_histogram( fill="#69b3a2", color="#e9ecef", bins=30, alpha=2) +
  geom_density(fill="black", alpha=0.2) +
  theme_gray() +
  labs(title="richness", subtitle =Richesse_tot_sub, x="Value", y="Density") +
  theme(plot.title = element_text(hjust = 0.5))
```

-   Transformation sqrt
```{r ,fig.dpi=300,fig.align='center',fig.height=4,fig.width=4}
df_2 <- data.frame(y =sqrt(landworm_explo$Richesse_tot))
# Test de Shapiro-Wilk
Richesse_tot_test_nor = shapiro.test(df_2$y)
Richesse_tot_p.value =round(Richesse_tot_test_nor$p.value,3)
 if(Richesse_tot_p.value ==0){
   Richesse_tot_p.value = "; p.value > 0.001"
 } else {
   Richesse_tot_p.value = paste0("; p.value = ",Richesse_tot_p.value)   
 }
Richesse_tot_sub = paste0("Shapiro-Wilk; W = ",round(Richesse_tot_test_nor$statistic,2),Richesse_tot_p.value)

```

```{r}
# Histogramme
ggplot(df_2, aes(x=y)) +
geom_histogram( fill="#69b3a2", color="#e9ecef", bins=30, alpha=2) +
  geom_density(fill="black", alpha=0.2) +
  theme_gray() +
  labs(title="richness", subtitle =Richesse_tot_sub, x="Value", y="Density") +
  theme(plot.title = element_text(hjust = 0.5))

```

:::

::: {.column width="50%"}

```{r}
# https://r-coder.com/box-cox-transformation-r/?utm_content=cmp-true
# landworm_explo$Richesse_tot[landworm_explo$Richesse_tot < 0]
x = as.numeric ( landworm_explo$Richesse_tot )+1


b <- MASS::boxcox(lm(x ~ 1),plotit = FALSE)

# Exact lambda
lambda1 <- b$x[which.max(b$y)]

MASS::boxcox(lm(x ~ 1),plotit = TRUE)


```
    lamda = `r lambda1`

<br/> 

```{r}
# QQ-plot
qqnorm(df$y)
qqline(df$y)
```

<br/> 
<br/> 

```{r}

# QQ-plot
qqnorm(df_2$y)
qqline(df_2$y)
```

:::
:::




## Standarization

-   Transformation sqrt de l'abondance et de la biomasse

-   Transformation centrée reduite des prédicteurs

```{r}
landworm_explo_non_t = landworm_explo
landworm_explo$AB_tot = sqrt(landworm_explo$AB_tot)
landworm_explo$BM_tot = sqrt(landworm_explo$BM_tot)
# landworm_explo$Richesse_tot = sqrt(landworm_explo$Richesse_tot)


landworm_explo[,all_predictors_num] = scale(landworm_explo[,all_predictors_num])

data_deep = landworm_explo # données pour les models RF, GBM et ANN




dummy_vars <- model.matrix(~ LC_ - 1, data = data_deep)
data_deep <- cbind(data_deep, dummy_vars)
# data_deep <- data_deep[, -which(names(data_deep) == "LC_")]


```






# Modeling


## Predictors

<br/> <br/> **All predictors: =\> RF, GBM et ANN**

<br/>

```{r}
# dput(all_predictors)
# dput(predictor_non_r)

predictor_non_r = c("LC_","Sand", "Clay", "pH", "N", "P", "K", "CN", "C_org", "tas_mean_6", "tas_mean_120", "tas_sd_3", "tas_sd_6", "tas_sd_120", "pr_mean_3", 
"pr_mean_120", "pr_sd_3", "pet_mean_6", "pet_sd_6")

LC_levels = c(paste0("LC_", new_cl))

predictor_deep = c("LC_", "Sand", "Silt", "Clay", "pH", "N", "P", 
"K", "CN", "CaCO3", "C_org", "tas_mean_3", "tas_mean_6", "tas_mean_120", 
"tas_sd_3", "tas_sd_6", "tas_sd_120", "tasmax_mean_3", "tasmax_mean_6", 
"tasmax_mean_120", "tasmax_sd_3", "tasmax_sd_6", "tasmax_sd_120", 
"tasmin_mean_3", "tasmin_mean_6", "tasmin_mean_120", "tasmin_sd_3", 
"tasmin_sd_6", "tasmin_sd_120", "pr_mean_3", "pr_mean_6", "pr_mean_120", 
"pr_sd_3", "pr_sd_6", "pr_sd_120", "pet_mean_3", "pet_mean_6", 
"pet_mean_120", "pet_sd_3", "pet_sd_6", "pet_sd_120")


vdt_col=c("AB_tot", "BM_tot", "Richesse_tot")

predictor_deep

# datatable(data.frame(Variables = predictor_deep))
```

<br/> 

**No correlation: =\> GLM et GAM** |0.7| 

<br/>

```{r}
# datatable(data.frame(Variables = predictor_non_r))
predictor_non_r
```

See [Correlation matrix]



## Variable selection Process

<br/>

***Initialization***

<br/>

***Model creation and evaluation Loop***

For each iteration `i` up to `length(variables) - 1`:

1. **Model creation**

    - We fit a model using all available predictor variables.

2. **Calculation of variable importance**

    - We use the permutation feature importance algorithm based on Fisher, Rudin, and Dominici (2018):
        - Input: model $\hat{F}$, variables $X$, target $y$, error measure $L(y, \hat{F}(X))$
        - Estimate the original model error $L_{original}$.
        - For each variable $j$:
            1. Permute $j$ in $X$ to obtain $X_{perm}$, thus breaking the association between $j$ and $y$.
            2. Estimate the error $L_{perm}$ with $X_{perm}$.
            3. Calculate the importance $FI_j = L_{perm} / L_{original}$.
        - Sort the variables by decreasing FI.

3. **Determination of the least important variable**

4. **Predictions on Test Data**

5. **Calculation of performance metrics**

    - `RMSE`, adjusted `R²` for training, `R²` for testing, and `MAE`.

6. **Update of Train and Test datasets**

    - Remove the least important variable from `train` & `test`.

**Recording of Results**



## Data preparation

```{r modeling AB_tot, echo=TRUE}
# AB_tot --------------------------------------------------------------------------
df_mod_AB_tot = data_deep[,c("AB_tot",predictor_deep, LC_levels)]
df_mod_AB_tot = drop_na(df_mod_AB_tot)
df_mod_AB_tot = droplevels(df_mod_AB_tot)


# Partition
# set.seed(123)
# ind <- sample(2, nrow(df_mod_AB_tot), replace = T, prob = c(.8, .2))
# AB_tot_train <- df_mod_AB_tot[ind==1,]
# AB_tot_test <- df_mod_AB_tot[ind==2,]

set.seed(42)
split <- rsample::initial_split(df_mod_AB_tot,prop = 0.8, strata = "AB_tot")
AB_tot_train <- rsample::training(split)
AB_tot_test <- rsample::testing(split)

write.csv2(x =AB_tot_train,file = "datas/landW/AB_tot_train.csv", row.names = FALSE)
write.csv2(x =AB_tot_test,file = "datas/landW/AB_tot_test.csv", row.names = FALSE)
# 
# AB_tot_train = read.csv2("datas/landW/AB_tot_train.csv")
# AB_tot_test = read.csv2("datas/landW/AB_tot_test.csv")
# df_mod_AB_tot = rbind(AB_tot_train,AB_tot_test)

AB_tot_train = as.data.frame(AB_tot_train)
AB_tot_test = as.data.frame(AB_tot_test)

df <- data.frame(y =AB_tot_train[,"AB_tot"])
abundance_dist_train = ggplot(df, aes(x=y)) +
geom_histogram( fill="#69b3a2", color="#e9ecef", bins=30, alpha=2) +
  geom_density(fill="black", alpha=0.2) +
  theme_gray() +
  labs(title="Abundance: Train", x="Value", y="Density") +
  theme(plot.title = element_text(hjust = 0.5))
# ggsave("Results/landW/abundance_dist_train.png", plot = abundance_dist_train, dpi = 300,width = 3,height = 2)

df <- data.frame(y =AB_tot_test[,"AB_tot"])
abundance_dist_test = ggplot(df, aes(x=y)) +
geom_histogram( fill="#69b3a2", color="#e9ecef", bins=30, alpha=2) +
  geom_density(fill="black", alpha=0.2) +
  theme_gray() +
  labs(title="Abundance: Test", x="Value", y="Density") +
  theme(plot.title = element_text(hjust = 0.5))
# ggsave("Results/landW/abundance_dist_test.png", plot = abundance_dist_test, dpi = 300,width = 3,height = 2)

# Distrvitbution de var rep dans train et de test: est ce homogene ?
abundance_dist_train_and_test = ggarrange(abundance_dist_train, abundance_dist_test,
                          labels = c('(a)', '(b)'),
                          common.legend = TRUE,
                          legend = 'right'
)


ggsave("Results/landW/abundance_dist_train_and_test.png", plot = abundance_dist_train_and_test, dpi = 300,height = 2,width = 4)

```


```{r modeling BM_tot}
# BM_tot --------------------------------------------------------------------------
df_mod_BM_tot = data_deep[,c("BM_tot",predictor_deep,LC_levels)]
df_mod_BM_tot = drop_na(df_mod_BM_tot)
df_mod_BM_tot = droplevels(df_mod_BM_tot)


# Partition
# set.seed(123)
# ind <- sample(2, nrow(df_mod_BM_tot), replace = T, prob = c(.8, .2))
# BM_tot_train <- df_mod_BM_tot[ind==1,]
# BM_tot_test <- df_mod_BM_tot[ind==2,]

set.seed(42)
split <- rsample::initial_split(df_mod_BM_tot, prop = 0.8, strata = "BM_tot")
BM_tot_train <- rsample::training(split)
BM_tot_test <- rsample::testing(split)


write.csv2(x =BM_tot_train,file = "datas/landW/BM_tot_train.csv", row.names = FALSE)
write.csv2(x =BM_tot_test,file = "datas/landW/BM_tot_test.csv", row.names = FALSE)
# 
# 
# BM_tot_train = read.csv2("datas/landW/BM_tot_train.csv")
# BM_tot_test = read.csv2("datas/landW/BM_tot_test.csv")
# df_mod_BM_tot = rbind(BM_tot_train,BM_tot_test)


BM_tot_train = as.data.frame(BM_tot_train)
BM_tot_test = as.data.frame(BM_tot_test)



# # Distribution de var rep
df <- data.frame(y =BM_tot_train[,"BM_tot"])
biomass_dist_train = ggplot(df, aes(x=y)) +
geom_histogram( fill="#69b3a2", color="#e9ecef", bins=30, alpha=2) +
  geom_density(fill="black", alpha=0.2) +
  theme_gray() +
  labs(title="Biomass: Train", x="Value", y="Density") +
  theme(plot.title = element_text(hjust = 0.5))
# ggsave("Results/landW/biomass_dist_train.png", plot = biomass_dist_train, dpi = 300,width = 3,height = 2)

df <- data.frame(y =BM_tot_test[,"BM_tot"])
biomass_dist_test = ggplot(df, aes(x=y)) +
geom_histogram( fill="#69b3a2", color="#e9ecef", bins=30, alpha=2) +
  geom_density(fill="black", alpha=0.2) +
  theme_gray() +
  labs(title="Biomass: Test", x="Value", y="Density") +
  theme(plot.title = element_text(hjust = 0.5))
# ggsave("Results/landW/biomass_dist_test.png", plot = biomass_dist_test, dpi = 300,width = 3,height = 2)


# Distrvitbution de var rep dans train et de test: est ce homogene ?
biomass_dist_train_and_test = ggarrange(biomass_dist_train, biomass_dist_test,
                                          labels = c('(a)', '(b)'),
                                          common.legend = TRUE,
                                          legend = 'right')

ggsave("Results/landW/biomass_dist_train_and_test.png", plot = biomass_dist_train_and_test, dpi = 300 ,height = 2,width = 4)
```


```{r modeling Richesse_tot}
# Richesse_tot -------------------------------------------------------------------------# plot(df_mod_Richesse_tot$Richesse_tot)
df_mod_Richesse_tot = data_deep[,c("Richesse_tot",predictor_deep,LC_levels)]
df_mod_Richesse_tot = drop_na(df_mod_Richesse_tot)
df_mod_Richesse_tot = droplevels(df_mod_Richesse_tot)


# Partition
# set.seed(123)
# ind <- sample(2, nrow(df_mod_Richesse_tot), replace = T, prob = c(.8, .2))
# Richesse_tot_train <- df_mod_Richesse_tot[ind==1,]
# Richesse_tot_test <- df_mod_Richesse_tot[ind==2,]

set.seed(42)
split <- rsample::initial_split(df_mod_Richesse_tot, prop = 0.8, strata = "Richesse_tot")
Richesse_tot_train <- rsample::training(split)
Richesse_tot_test <- rsample::testing(split)

write.csv2(x =Richesse_tot_train,file = "datas/landW/Richesse_tot_train.csv", row.names = FALSE)
write.csv2(x =Richesse_tot_test,file = "datas/landW/Richesse_tot_test.csv", row.names = FALSE)
# 
# Richesse_tot_train = read.csv2("datas/landW/Richesse_tot_train.csv")
# Richesse_tot_test = read.csv2("datas/landW/Richesse_tot_test.csv")
# df_mod_Richesse_tot = rbind(Richesse_tot_train,Richesse_tot_test)


Richesse_tot_train = as.data.frame(Richesse_tot_train)
Richesse_tot_test = as.data.frame(Richesse_tot_test)


# Distribution de var rep
df <- data.frame(y =Richesse_tot_train[,"Richesse_tot"])
richness_dist_train = ggplot(df, aes(x=y)) +
geom_histogram( fill="#69b3a2", color="#e9ecef", bins=30, alpha=2) +
  geom_density(fill="black", alpha=0.2) +
  theme_gray() +
  labs(title="Richness: Train", x="Value", y="Density") +
  theme(plot.title = element_text(hjust = 0.5))
# ggsave("Results/landW/richness_dist_train.png", plot = richness_dist_train, dpi = 300 ,width = 3,height = 2)

df <- data.frame(y =Richesse_tot_test[,"Richesse_tot"])
richness_dist_test = ggplot(df, aes(x=y)) +
geom_histogram( fill="#69b3a2", color="#e9ecef", bins=30, alpha=2) +
  geom_density(fill="black", alpha=0.2) +
  theme_gray() +
  labs(title="Richness: Test", x="Value", y="Density") +
  theme(plot.title = element_text(hjust = 0.5))
# ggsave("Results/landW/richness_dist_test.png", plot = richness_dist_test, dpi = 300 ,width = 3,height = 2)

# Distrvitbution de var rep dans train et de test: est ce homogene ?
richness_dist_train_and_test = ggarrange(richness_dist_train, richness_dist_test,
                                          labels = c('(a)', '(b)'),
                                          common.legend = TRUE,
                                          legend = 'right')

ggsave("Results/landW/richness_dist_train_and_test.png", plot = richness_dist_train_and_test, dpi = 300 ,height = 2,width = 4)

```


    
::: columns
::: {.column width="50%"}

**Abundance **

-   Data partition (`r dim(df_mod_AB_tot)`):

    -   train data (80 %) = `r dim(AB_tot_train) `
    
    -   test data (20 %) = `r dim(AB_tot_test) `
    


**Biomasse **

-   Data partition (`r dim(df_mod_BM_tot)`):

    -   train data (80 %) = `r dim(BM_tot_train) `
    
    -   test data (20 %) = `r dim(BM_tot_test) `
    


**Richness **

-   Data partition (`r dim(df_mod_Richesse_tot)`):

    -   train data (80 %) = `r dim(Richesse_tot_train) `
    
    -   test data (20 %) = `r dim(Richesse_tot_test) ` 

:::

::: {.column width="50%"}
<p>
  <img src="Results/landW/abundance_dist_train_and_test.png">
</p>

<p>
  <img src="Results/landW/biomass_dist_train_and_test.png">
</p>

<p>
  <img src="Results/landW/richness_dist_train_and_test.png">
</p>
:::
:::




## GLM

```{r function GLM, echo=TRUE}
GLM <- function(var_rep, df_app, df_valid,family = 'gaussian'){
  
  
  var_predicteurs = names(df_app[,-1])
 
  df_app = df_app[,c(var_rep,var_predicteurs)]
  df_valid = df_valid[,c(var_rep,var_predicteurs)]
  
  formula <- substitute(var_rep ~ ., list(var_rep = as.name(var_rep)))
  
  
  # entrainement du modele sur le jeu d'entrainement
  modelglm<-glm(formula,family = family ,data = df_app)
  
  # Prediction sur le jeu de validation
  pred.GLM<-predict(modelglm,newdata=as.data.frame(df_valid[,var_predicteurs]))
  
  # Calcul du RMSE pour évaluer la qualite du modele
  rmse <- round (sqrt(mean((df_valid[,var_rep] - pred.GLM)^2,na.rm=TRUE)),2)
  
  
 # Calcul du R² ajusté pour train
  R_adj_train <- calcule_R2(df_app[,var_rep],  predict(modelglm, newdata=df_app))
  n_train <- nrow(df_app)
  p_train <- ncol(df_app) - 1
  r_adj_train <- 1 - ((1 - R_adj_train) * (n_train - 1) / (n_train - p_train - 1))
  
  # Calcul du R² 
  # R_adj_test <-calcule_R2(df_valid[,var_rep],pred.GLM)
  # n_test <- nrow(df_valid)
  # p_test <- ncol(df_valid) - 1
  # r_adj_test <- 1 - ((1 - R_adj_test) * (n_test - 1) / (n_test - p_test - 1))
  
  res <- rms::lrm(df_valid[,var_rep]  ~ pred.GLM, x= TRUE, y = TRUE)
  res = res$stats
  r_adj_test = round (res[["R2"]],2)
  
  MAE <- mean(abs(pred.GLM - df_valid[,var_rep]),na.rm=TRUE)
  
  # Round results
  rmse <- round(rmse, 2)
  r_adj_train <- round(r_adj_train, 2)
  r_adj_test <- round(r_adj_test, 2)
  MAE <- round(MAE, 2)
  
  # output
  results_df <- data.frame(Algorithms = "GLM",
                         Response_variables = var_rep,
                         R2_adjusted_train = r_adj_train,
                         R2_adjusted_test = r_adj_test,
                         RMSE = rmse,
                         MAE = MAE)
    
  
  results <- list(RMSE = rmse, R_adj_train = r_adj_train, R_adj_test = r_adj_test, MAE = MAE, model = modelglm,predit = pred.GLM, df = results_df)
  return(results)
}

```

-   Gaussian distribution


## GAM
```{r function GAM, echo=TRUE}
GAM <- function(var_rep, df_app, df_valid, family = 'gaussian',method = "REML", interaction = FALSE){
  
  var_predicteurs = names(df_app[,-1])
  
  
  if (var_rep == "AB_tot"){ 

  modelgam<-gam(AB_tot ~ s(CaCO3) + s(gps_x) + s(N) + s(tasmax) + s(gps_y) + s(clay) + s(silt) + s(P) + s(bio12) + clcm_lvl3f + clcm_lvl3gua + clcm_lvl3ng + clcm_lvl3nial + clcm_lvl3p + clcm_lvl3v,
        family=family,method = method,data = df_app)
  
  }
  
  
  
  
  if (var_rep == "BM_tot"){ 

  modelgam<-gam(BM_tot ~ s(CaCO3) + s(gps_x) + s(N) + s(tasmax) + s(gps_y) + s(clay) + s(silt) + s(P) + s(bio12) + clcm_lvl3f + clcm_lvl3gua + clcm_lvl3ng + clcm_lvl3nial + clcm_lvl3p + clcm_lvl3v,
        family=family,method = method,data = df_app)
  
    
  }
  
  
  
  if(var_rep == "Richesse_tot"){ 
    
  modelgam<-gam(Richesse_tot ~ s(CaCO3) + s(gps_x) + s(N) + s(tasmax) + s(gps_y) + s(clay) + s(silt) + s(P) + s(bio12) + clcm_lvl3f + clcm_lvl3gua + clcm_lvl3ng + clcm_lvl3nial + clcm_lvl3p + clcm_lvl3v ,
        family=family,method = method,data = df_app)
   
  }
  
  
  # Prediction sur le jeu de validation
  pred.GAM <- predict(modelgam,newdata=as.data.frame(df_valid[,var_predicteurs]))
  
  # Calcul du RMSE pour évaluer la qualite du modele
  rmse <- sqrt(mean((df_valid[,var_rep] - pred.GAM)^2,na.rm=TRUE))

  
# Calcul du R² ajusté pour train
  R_adj_train <- calcule_R2(df_app[,var_rep],  predict(modelgam, newdata=df_app))
  n_train <- nrow(df_app)
  p_train <- ncol(df_app) - 1
  r_adj_train <- 1 - ((1 - R_adj_train) * (n_train - 1) / (n_train - p_train - 1))
  
  # Calcul du R² ajusté pour test
  # R_adj_test <-calcule_R2(df_valid[,var_rep],pred.GAM)
  # n_test <- nrow(df_valid)
  # p_test <- ncol(df_valid) - 1
  # r_adj_test <- 1 - ((1 - R_adj_test) * (n_test - 1) / (n_test - p_test - 1))
    res <- rms::lrm(df_valid[,var_rep]  ~ pred.GAM, x= TRUE, y = TRUE)
  res = res$stats
  r_adj_test = round (res[["R2"]],2)
  

  # Calcule le MAE
  MAE <- mean(abs(pred.GAM - df_valid[,var_rep]))
  
  # Round results
  rmse <- round(rmse, 2)
  r_adj_train <- round(r_adj_train, 2)
  r_adj_test <- round(r_adj_test, 2)
  MAE <- round(MAE, 2)
  
  
  # output
  results_df <- data.frame(Algorithms = "GAM",
                         Response_variables = var_rep,
                         R2_adjusted_train = r_adj_train,
                         R2_adjusted_test = r_adj_test,
                         RMSE = rmse,
                         MAE = MAE)
  
  
  results <- list(RMSE = rmse, R_adj_train = r_adj_train, R_adj_test = r_adj_test, MAE = MAE, model = modelgam, predit = pred.GAM, df = results_df)
  
  return(results)
}

```

-   Family = gaussian 

-   Link function = identity 

-   Method = REML

-   Tuning



## RF


-   Default model


```{r}
# Grille de hyperparametisation
RF_df_grid <- expand.grid(ntree = c(100,300,500,700,900,1000,1300,1500,1700,2000),
                       mtry = c(2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24),
                       nodesize = c(10 , 20,  30,  40,  50,  60,  70,  80))
```


-   RF model tuning by grid


  -   ntree = $100,300,500,700,900,1000,1300,1500,1700,2000$
  
  
  -   mtry = $2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24$
  
  
  -   maxnodes = $10 , 20,  30,  40,  50,  60,  70,  80,  90, 100$
  
  
 **Total number of models = $ntree * mtry * maxnode = `r nrow(RF_df_grid)`$ **
 
  
 -    Validation of models on test data
  

```{r function RF, echo=TRUE,fig.align='center'}
ForetAlea <- function(var_rep, df_app, df_valid, mtry, ntree, maxnodes) {
  
  set.seed(1863)
  col_posi <- which(names(df_app) == var_rep)
  ForeVDT <- randomForest::randomForest(df_app[-col_posi], df_app[[col_posi]], mtry = mtry, ntree = ntree, maxnodes = maxnodes)
  
  # Prediction on the validation dataset
  col_posi <- which(names(df_valid) == var_rep)
  pred.RF <- predict(ForeVDT, newdata = df_valid[, -col_posi])
  
  # Calculate RMSE to evaluate model quality
  rmse <- sqrt(mean((df_valid[, col_posi] - pred.RF)^2))
  
  
  # Calcul du R² ajusté pour train
  R_adj_train <- calcule_R2(df_app[,var_rep],  predict(ForeVDT, newdata=df_app))
  n_train <- nrow(df_app)
  p_train <- ncol(df_app) - 1
  r_adj_train <- 1 - ((1 - R_adj_train) * (n_train - 1) / (n_train - p_train - 1))
  
  # Calcul du R² ajusté pour test
  # R_adj_test <-calcule_R2(df_valid[,col_posi],pred.RF)
  # n_test <- nrow(df_valid)
  # p_test <- ncol(df_valid) - 1
  # r_adj_test <- 1 - ((1 - R_adj_test) * (n_test - 1) / (n_test - p_test - 1))
  res <- rms::lrm(df_valid[,var_rep]  ~ pred.RF, x= TRUE, y = TRUE)
  res = res$stats
  r_adj_test = round (res[["R2"]],2)
  
  # Calculate MAE
  MAE <- mean(abs(pred.RF - df_valid[, col_posi]))
  
  # Round results
  rmse <- round(rmse, 2)
  r_adj_train <- round(r_adj_train, 2)
  r_adj_test <- round(r_adj_test, 2)
  MAE <- round(MAE, 2)
  
    # output
  results_df <- data.frame(Algorithms = "RF",
                         Response_variables = var_rep,
                         R2_adjusted_train = r_adj_train,
                         R2_adjusted_test = r_adj_test,
                         RMSE = rmse,
                         MAE = MAE)
  
  
  results <- list(RMSE = rmse, R_adj_train = r_adj_train, R_adj_test = r_adj_test, MAE = MAE, model = ForeVDT, predit = pred.RF, df = results_df)
  
  return(results)
}
```






## GBM

```{r}
# Grille de hyperparametisation
GBM_df_grid <- expand.grid(n.trees = c(1000,1500,1700,2000,3000),
                       interaction.depth = c(3,  5,  6,  8, 10),
                       shrinkage = c(0.01, 0.02, 0.05, 0.001, 0.002, 0.005),
                       n.minobsinnode = c(2 , 5,  10,  30,  50,  70))
```

-   Default model


-   GBM model tuning by grid


  -   n.trees = $1000, 1500, 1700, 2000, 3000$
  
  
  -   shrinkage = $0.01, 0.02, 0.05, 0.001, 0.002, 0.005$
  
  
  -   interaction.depth = $3,  5,  6,  8, 10$
  
  
  -   n.minobsinnode = $2, 5,  10,  30,  50,  70$
  
  
  **Total number of models = $n.trees * shrinkage * interaction.depth * n.minobsinnode = `r nrow(GBM_df_grid)`$ **
  
  
-   Validation of models on test data
  

```{r function GBM, echo=TRUE}
GBM <- function(var_rep, df_app, df_valid,distribution = 'gaussian',n.trees ,shrinkage,interaction.depth,n.minobsinnode){

  formula <- substitute(var_rep ~ ., list(var_rep = as.name(var_rep)))

  Gradboost<-gbm(formula, data = df_app,
    distribution = distribution, 
    n.trees = n.trees,
    shrinkage = shrinkage,
    interaction.depth = interaction.depth,
    n.minobsinnode = n.minobsinnode) 
  
  # Prediction sur le jeu de validation :
   col_posi <- which(names(df_valid) == var_rep)
  prev.GBM<-predict(Gradboost,newdata=as.data.frame(df_valid[,-col_posi]))
 
  # Calcul du RMSE pour évaluer la qualité du modele
  rmse <- sqrt(mean((df_valid[,var_rep] - prev.GBM)^2))


# Calcul du R² ajusté pour train
  R_adj_train <- calcule_R2(df_app[,var_rep],  predict(Gradboost, newdata=df_app))
  n_train <- nrow(df_app)
  p_train <- ncol(df_app) - 1
  r_adj_train <- 1 - ((1 - R_adj_train) * (n_train - 1) / (n_train - p_train - 1))
  
  # Calcul du R² ajusté pour test
  # R_adj_test <-calcule_R2(df_valid[,col_posi],prev.GBM)
  # n_test <- nrow(df_valid)
  # p_test <- ncol(df_valid) - 1
  # r_adj_test <- 1 - ((1 - R_adj_test) * (n_test - 1) / (n_test - p_test - 1))
    res <- rms::lrm(df_valid[,var_rep]  ~ prev.GBM, x= TRUE, y = TRUE)
  res = res$stats
  r_adj_test = round (res[["R2"]],2)
  

  # calcule MAE
  MAE <- mean(abs(prev.GBM - df_valid[,col_posi])) 
  
    
    # Round results
  rmse <- round(rmse, 2)
  r_adj_train <- round(r_adj_train, 2)
  r_adj_test <- round(r_adj_test, 2)
  MAE <- round(MAE, 2)
  
  
      # output
  results_df <- data.frame(Algorithms = "GBM",
                         Response_variables = var_rep,
                         R2_adjusted_train = r_adj_train,
                         R2_adjusted_test = r_adj_test,
                         RMSE = rmse,
                         MAE = MAE)
  
  
  results <- list(RMSE = rmse, R_adj_train = r_adj_train, R_adj_test = r_adj_test, MAE = MAE, model = Gradboost, predit = prev.GBM, df = results_df)
  
  
  return(results)
}
```





## ANN







## Compilation


-   ANN AB_tot

```{r ANN AB_tot, eval=FALSE}
# Pour AB_tot  ------------------------------------------------------------------
var_rep="AB_tot"
AB_tot_ANN_tuning = read.csv2("results_tuning/AB_tot_ANN_tuning.csv")

# Best hyperparameter values
AB_tot_ANN_tuning = as.data.frame(AB_tot_ANN_tuning)
AB_tot_ANN_tuning = AB_tot_ANN_tuning %>% arrange(metric_val_mae)
# head(AB_tot_ANN_tuning[,2:16])

best_param = AB_tot_ANN_tuning[1,]


dense_units1 = as.numeric(best_param$flag_dense_units1)
dense_units2 = as.numeric(best_param$flag_dense_units2)
dense_units3 = as.numeric(best_param$flag_dense_units3)
dense_units4 = as.numeric(best_param$flag_dense_units4)

dropout1 =as.numeric(best_param$flag_dropout1)
dropout2 =as.numeric(best_param$flag_dropout2)
dropout3 =as.numeric(best_param$flag_dropout3)
dropout4 =as.numeric(best_param$flag_dropout4)

batch_size =as.numeric(best_param$flag_batch_size)


# data
training = AB_tot_train
test = AB_tot_test

training %<>% mutate_if(is.factor, as.numeric)
ind_var_rep <- which(names(training) == var_rep)
trainingtarget <- training[, ind_var_rep]
training <- training[, -ind_var_rep]
training <- as.matrix(training)
dimnames(training) <- NULL

ind_var_rep <- which(names(test) == var_rep)
testtarget <- test[, ind_var_rep]
test <- test[, -ind_var_rep]
test %<>% mutate_if(is.factor, as.numeric)
test <- as.matrix(test)
dimnames(test) <- NULL


# AB_tot TUNE MODEL
ANN_tune_AB_tot <- keras_model_sequential()
ANN_tune_AB_tot %>% 
  layer_dense(units = dense_units1, activation = 'relu', input_shape = c(15)) %>%
  layer_dropout(rate = dropout1)  %>%
  layer_dense(units = dense_units2, activation = 'relu') %>%
  layer_dropout(rate = dropout2)  %>%
  layer_dense(units = dense_units3, activation = 'relu') %>%
  layer_dropout(rate = dropout3)  %>%
  layer_dense(units = dense_units4, activation = 'relu') %>%
  layer_dropout(rate = dropout4)  %>%
  layer_dense(units = 1)


# Compile
ANN_tune_AB_tot %>% keras::compile(loss = 'mse',
                  optimizer = 'rmsprop',
                  metrics = 'mae')

#  callback EarlyStopping
mon_callback <- callback_early_stopping(
  monitor = "val_mae",  # Surveille la perte sur l'ensemble de validation
  patience = 10,         # Nombre d'époques sans amélioration avant l'arrêt
  restore_best_weights = TRUE  # Restaure les poids du meilleur modèle
)


# Fit ANN_tune_AB_tot
myANN_tune_AB_tot <- ANN_tune_AB_tot %>%
  fit(training,
      trainingtarget,
      epochs = 100,
      batch_size = batch_size,
      validation_split = 0.2,
      #callbacks = list(mon_callback)
      )


# fig_ANN_tune_AB_tot = plot(myANN_tune_AB_tot)
# ggsave("Results/landW/fig_ANN_tune_AB_tot.png", plot = fig_ANN_tune_AB_tot, dpi = 300)

# Evaluate
# ANN_tune_AB_tot %>% evaluate(test, testtarget)
ANN_tune_AB_tot_pred = ANN_tune_AB_tot %>% predict(test)
ANN_tune_AB_tot_mse = mean((testtarget-ANN_tune_AB_tot_pred)^2) # loss -> mse
ANN_tune_AB_tot_mae = mean(abs(ANN_tune_AB_tot_pred - testtarget),na.rm=TRUE) # MAE 
ANN_tune_AB_tot_rmse = sqrt(mean((testtarget - ANN_tune_AB_tot_pred)^2,na.rm=TRUE)) # rmse
ANN_tune_AB_tot_cor = cor(testtarget,ANN_tune_AB_tot_pred)^2 # R²



# Calcul du R² ajusté pour train
  R_adj_train <- calcule_R2(trainingtarget,  ANN_tune_AB_tot %>% predict(training))
  n_train <- nrow(training)
  p_train <- ncol(training)
  r_adj_train <- 1 - ((1 - R_adj_train) * (n_train - 1) / (n_train - p_train - 1))
  
  # Calcul du R² ajusté pour test
  # R_adj_test <-calcule_R2(testtarget,ANN_tune_AB_tot_pred)
  # n_test <- nrow(test)
  # p_test <- ncol(test)
  # r_adj_test <- 1 - ((1 - R_adj_test) * (n_test - 1) / (n_test - p_test - 1))
  
  res <- rms::lrm(testtarget  ~ ANN_tune_AB_tot_pred, x= TRUE, y = TRUE)
  res = res$stats
  r_adj_test = round (res[["R2"]],2)
  
  

ANN_tune_AB_tot_results = data.frame(model = "ANN_tune_AB_tot",
                                     mse = round(ANN_tune_AB_tot_mse,2),                                                        mae = round(ANN_tune_AB_tot_mae,2),
                                     rmse = round(ANN_tune_AB_tot_rmse,2), 
                                     R_adj_train= round(r_adj_train,2),
                                     R_adj_test= round(r_adj_test,2))

      # output
ANN_tune_AB_tot_results_df <- data.frame(Algorithms = "ANN",
                         Response_variables = "AB_tot",
                         R2_adjusted_train = r_adj_train,
                         R2_adjusted_test = r_adj_test,
                         RMSE = ANN_tune_AB_tot_rmse,
                         MAE = ANN_tune_AB_tot_mae)
  
# ANN_tune_AB_tot_results

```


-   ANN BM_tot

```{r ANN BM_tot, eval=FALSE}
# Pour BM_tot  ------------------------------------------------------------------
var_rep="BM_tot"
BM_tot_ANN_tuning = read.csv2("results_tuning/BM_tot_ANN_tuning.csv")

# Best hyperparameter values
BM_tot_ANN_tuning = as.data.frame(BM_tot_ANN_tuning)
BM_tot_ANN_tuning = BM_tot_ANN_tuning %>% arrange(metric_val_mae)
# head(BM_tot_ANN_tuning[,2:16])

best_param = BM_tot_ANN_tuning[1,]

dense_units1 = as.numeric(best_param$flag_dense_units1)
dense_units2 = as.numeric(best_param$flag_dense_units2)
dense_units3 = as.numeric(best_param$flag_dense_units3)
dense_units4 = as.numeric(best_param$flag_dense_units4)

dropout1 =as.numeric(best_param$flag_dropout1)
dropout2 =as.numeric(best_param$flag_dropout2)
dropout3 =as.numeric(best_param$flag_dropout3)
dropout4 =as.numeric(best_param$flag_dropout4)

batch_size =as.numeric(best_param$flag_batch_size)


# data
training = BM_tot_train
test = BM_tot_test

training %<>% mutate_if(is.factor, as.numeric)
ind_var_rep <- which(names(training) == var_rep)
trainingtarget <- training[, ind_var_rep]
training <- training[, -ind_var_rep]
training <- as.matrix(training)
dimnames(training) <- NULL

ind_var_rep <- which(names(test) == var_rep)
testtarget <- test[, ind_var_rep]
test <- test[, -ind_var_rep]
test %<>% mutate_if(is.factor, as.numeric)
test <- as.matrix(test)
dimnames(test) <- NULL


# BM_tot TUNE MODEL
ANN_tune_BM_tot <- keras_model_sequential()
ANN_tune_BM_tot %>% 
  layer_dense(units = dense_units1, activation = 'relu', input_shape = c(15)) %>%
  layer_dropout(rate = dropout1)  %>%
  layer_dense(units = dense_units2, activation = 'relu') %>%
  layer_dropout(rate = dropout2)  %>%
  layer_dense(units = dense_units3, activation = 'relu') %>%
  layer_dropout(rate = dropout3)  %>%
  layer_dense(units = dense_units4, activation = 'relu') %>%
  layer_dropout(rate = dropout4)  %>%
  layer_dense(units = 1)


# Compile
ANN_tune_BM_tot %>% keras::compile(loss = 'mse',
                  optimizer = 'rmsprop',
                  metrics = 'mae')

#  callback EarlyStopping
mon_callback <- callback_early_stopping(
  monitor = "val_mae",  # Surveille la perte sur l'ensemble de validation
  patience = 10,         # Nombre d'époques sans amélioration avant l'arrêt
  restore_best_weights = TRUE  # Restaure les poids du meilleur modèle
)


# Fit ANN_tune_BM_tot
myANN_tune_BM_tot <- ANN_tune_BM_tot %>%
  fit(training,
      trainingtarget,
      epochs = 100,
      batch_size = batch_size,
      validation_split = 0.2,
      #callbacks = list(mon_callback)
      )

# fig_ANN_tune_BM_tot = plot(myANN_tune_BM_tot)
# ggsave("Results/landW/fig_ANN_tune_BM_tot.png", plot = fig_ANN_tune_BM_tot, dpi = 300)


# Evaluate
# ANN_tune_BM_tot %>% evaluate(test, testtarget)
ANN_tune_BM_tot_pred = ANN_tune_BM_tot %>% predict(test)
ANN_tune_BM_tot_mse = mean((testtarget-ANN_tune_BM_tot_pred)^2) # loss -> mse
ANN_tune_BM_tot_mae = mean(abs(ANN_tune_BM_tot_pred - testtarget),na.rm=TRUE) # MAE 
ANN_tune_BM_tot_rmse = sqrt(mean((testtarget - ANN_tune_BM_tot_pred)^2,na.rm=TRUE)) # rmse
ANN_tune_BM_tot_cor = cor(testtarget,ANN_tune_BM_tot_pred)^2 # R²



# Calcul du R² ajusté pour train
  R_adj_train <- calcule_R2(trainingtarget,  ANN_tune_BM_tot %>% predict(training))
  n_train <- nrow(training)
  p_train <- ncol(training)
  r_adj_train <- 1 - ((1 - R_adj_train) * (n_train - 1) / (n_train - p_train - 1))
  
  # Calcul du R² ajusté pour test
  # R_adj_test <-calcule_R2(testtarget,ANN_tune_BM_tot_pred)
  # n_test <- nrow(test)
  # p_test <- ncol(test)
  # r_adj_test <- 1 - ((1 - R_adj_test) * (n_test - 1) / (n_test - p_test - 1))
    res <- rms::lrm(testtarget  ~ ANN_tune_BM_tot_pred, x= TRUE, y = TRUE)
  res = res$stats
  r_adj_test = round (res[["R2"]],2)
  
  
  

ANN_tune_BM_tot_results = data.frame(model = "ANN_tune_BM_tot",
                                     mse = round(ANN_tune_BM_tot_mse,2),                                                        mae = round(ANN_tune_BM_tot_mae,2),
                                     rmse = round(ANN_tune_BM_tot_rmse,2), 
                                     R_adj_train= round(r_adj_train,2),
                                     R_adj_test= round(r_adj_test,2))
# ANN_tune_BM_tot_results


      # output
ANN_tune_BM_tot_results_df <- data.frame(Algorithms = "ANN",
                         Response_variables = "BM_tot",
                         R2_adjusted_train = r_adj_train,
                         R2_adjusted_test = r_adj_test,
                         RMSE = ANN_tune_BM_tot_rmse,
                         MAE = ANN_tune_BM_tot_mae)


```

-   ANN Richesse_tot

```{r ANN Richesse_tot, eval=FALSE}
# Pour Richesse_tot  ------------------------------------------------------------------
var_rep="Richesse_tot"
Richesse_tot_ANN_tuning = read.csv2("results_tuning/Richesse_tot_ANN_tuning.csv")

# Best hyperparameter values
Richesse_tot_ANN_tuning = as.data.frame(Richesse_tot_ANN_tuning)
Richesse_tot_ANN_tuning = Richesse_tot_ANN_tuning %>% arrange(metric_val_mae)
# head(Richesse_tot_ANN_tuning[,2:16])

best_param = Richesse_tot_ANN_tuning[1,]

dense_units1 = as.numeric(best_param$flag_dense_units1)
dense_units2 = as.numeric(best_param$flag_dense_units2)
dense_units3 = as.numeric(best_param$flag_dense_units3)
dense_units4 = as.numeric(best_param$flag_dense_units4)

dropout1 =as.numeric(best_param$flag_dropout1)
dropout2 =as.numeric(best_param$flag_dropout2)
dropout3 =as.numeric(best_param$flag_dropout3)
dropout4 =as.numeric(best_param$flag_dropout4)

batch_size =as.numeric(best_param$flag_batch_size)


# data
training = Richesse_tot_train
test = Richesse_tot_test

training %<>% mutate_if(is.factor, as.numeric)
ind_var_rep <- which(names(training) == var_rep)
trainingtarget <- training[, ind_var_rep]
training <- training[, -ind_var_rep]
training <- as.matrix(training)
dimnames(training) <- NULL

ind_var_rep <- which(names(test) == var_rep)
testtarget <- test[, ind_var_rep]
test <- test[, -ind_var_rep]
test %<>% mutate_if(is.factor, as.numeric)
test <- as.matrix(test)
dimnames(test) <- NULL


# Richesse_tot TUNE MODEL
ANN_tune_Richesse_tot <- keras_model_sequential()
ANN_tune_Richesse_tot %>% 
  layer_dense(units = dense_units1, activation = 'relu', input_shape = c(15)) %>%
  layer_dropout(rate = dropout1+0.2)  %>%
  layer_dense(units = dense_units2, activation = 'relu') %>%
  layer_dropout(rate = dropout2+0.2)  %>%
  layer_dense(units = dense_units3, activation = 'relu') %>%
  layer_dropout(rate = dropout3+0.2)  %>%
  layer_dense(units = dense_units4, activation = 'relu') %>%
  layer_dropout(rate = dropout4+0.2)  %>%
  layer_dense(units = 1)


# Compile
ANN_tune_Richesse_tot %>% keras::compile(loss = 'mse',
                  optimizer = 'rmsprop',
                  metrics = 'mae')

#  callback EarlyStopping
mon_callback <- callback_early_stopping(
  monitor = "val_mae",  # Surveille la perte sur l'ensemble de validation
  patience = 10,         # Nombre d'époques sans amélioration avant l'arrêt
  restore_best_weights = TRUE  # Restaure les poids du meilleur modèle
)


# Fit ANN_tune_Richesse_tot
myANN_tune_Richesse_tot <- ANN_tune_Richesse_tot %>%
  fit(training,
      trainingtarget,
      epochs = 100,
      batch_size = batch_size,
      validation_split = 0.2,
      #callbacks = list(mon_callback)
      )


# fig_ANN_tune_Richesse_tot = plot(myANN_tune_Richesse_tot)
# ggsave("Results/landW/fig_ANN_tune_Richesse_tot.png", plot = fig_ANN_tune_Richesse_tot, dpi = 300)

# Evaluate
# ANN_tune_Richesse_tot %>% evaluate(test, testtarget)
ANN_tune_Richesse_tot_pred = ANN_tune_Richesse_tot %>% predict(test)
ANN_tune_Richesse_tot_mse = mean((testtarget-ANN_tune_Richesse_tot_pred)^2) # loss -> mse
ANN_tune_Richesse_tot_mae = mean(abs(ANN_tune_Richesse_tot_pred - testtarget),na.rm=TRUE) # MAE 
ANN_tune_Richesse_tot_rmse = sqrt(mean((testtarget - ANN_tune_Richesse_tot_pred)^2,na.rm=TRUE)) # rmse
ANN_tune_Richesse_tot_cor = cor(testtarget,ANN_tune_Richesse_tot_pred)^2 # R²



# Calcul du R² ajusté pour train
  R_adj_train <- calcule_R2(trainingtarget,  ANN_tune_Richesse_tot %>% predict(training))
  n_train <- nrow(training)
  p_train <- ncol(training)
  r_adj_train <- 1 - ((1 - R_adj_train) * (n_train - 1) / (n_train - p_train - 1))
  
  # Calcul du R² ajusté pour test
  # R_adj_test <-calcule_R2(testtarget,ANN_tune_Richesse_tot_pred)
  # n_test <- nrow(test)
  # p_test <- ncol(test)
  # r_adj_test <- 1 - ((1 - R_adj_test) * (n_test - 1) / (n_test - p_test - 1))
  res <- rms::lrm(testtarget  ~ ANN_tune_Richesse_tot_pred, x= TRUE, y = TRUE)
  res = res$stats
  r_adj_test = round (res[["R2"]],2)
  
  
  

ANN_tune_Richesse_tot_results = data.frame(model = "ANN_tune_Richesse_tot",
                                     mse = round(ANN_tune_Richesse_tot_mse,2),                                            mae = round(ANN_tune_Richesse_tot_mae,2),
                                     rmse = round(ANN_tune_Richesse_tot_rmse,2), 
                                     R_adj_train= round(r_adj_train,2),
                                     R_adj_test= round(r_adj_test,2))
# ANN_tune_Richesse_tot_results


# output
ANN_tune_Richesse_tot_results_df <- data.frame(Algorithms = "ANN",
                         Response_variables = "Richesse_tot",
                         R2_adjusted_train = r_adj_train,
                         R2_adjusted_test = r_adj_test,
                         RMSE = ANN_tune_Richesse_tot_rmse,
                         MAE = ANN_tune_Richesse_tot_mae)

```


**Summary of Compilations**

-   For GLM and GAM, there were 19 explanatory variables => $18*5*3*2 = 540$

-   For RF, GBM, and ANN, there were 41 variables => $40*5*3*3 = 1800$

*Excluding optimization models*


# R² ajustés

## R² dans les modèles de régression non linéaire

"Le R² ajusté est utile pour les modèles de régression linéaire, il est moins pertinent pour les modèles de machine learning en raison de la complexité des modèle."



La formule du coefficient de détermination $R^2$ est :

\begin{equation}
R^2 = 1 - \frac{\sum_{i=1}^{n} (y_i - \hat{y}_i)^2}{\sum_{i=1}^{n} (y_i - \bar{y})^2}
\end{equation}

où :

-   $ y_i $ est la valeur observée,
-   $ \hat{y}_i $ est la valeur prédite par le modèle,
-   $ \bar{y} $ est la moyenne des valeurs observées,
-   $ n $ est le nombre total d'observations.




La formule du $R²$ ajusté est :

\begin{equation}
R^2_{\text{ajusté}} = 1 - \left( \frac{(1 - R^2) \cdot (n - 1)}{n - k - 1} \right)
\end{equation}

où :

-   $R²$ est le coefficient de détermination,
-   $n$ est le nombre total d'observations,
-   $k$ est le nombre de prédicteurs (variables indépendantes) dans le modèle.



**Justificatifs**

See [towardsdatascience.com](https://towardsdatascience.com/the-complete-guide-to-r-squared-adjusted-r-squared-and-pseudo-r-squared-4136650fc06c){target="_blank"}

"La procédure d'ajustement du modèle des models non linéaires ne repose pas sur la minimisation progressive de la somme des carrés des erreurs résiduelles (RSS) et, par conséquent, le modèle ajusté de manière optimale pourrait avoir une somme des carrés résiduels supérieure à la somme totale des carrés. Cela signifie que R² pour de tels modèles peut être une quantité négative. En tant que tel, R² n'est pas une mesure utile de la qualité de l'ajustement pour la plupart des modèles non linéaires."



"Les modèles non linéaires utilisent souvent des techniques d'ajustement de modèle telles que l'estimation de vraisemblance maximale (MLE) qui ne minimisent pas nécessairement la somme des carrés résiduels (RSS). Ainsi, étant donné deux modèles non linéaires ajustés à l'aide de MLE, celui qui présente la meilleure qualité d'ajustement peut se révéler avoir un R² ou un R² ajusté plus faible. Une autre conséquence de ce fait est que l'ajout de variables de régression aux modèles non linéaires peut réduire le R². Globalement, le R² ou le R² ajusté ne doivent pas être utilisés pour juger de la qualité d'ajustement d'un modèle de régression non linéaire."

"De nombreux modèles de régression non linéaires n'utilisent pas la technique d'estimation des moindres carrés ordinaires pour ajuster le modèle."



# LandWorm results: total abundance

[Abundance: best models]

## Abundance: GLM

```{r reslt_glm_AB_tot, fig.align='center'}
AB_tot_select_GLM = read.xlsx("variables_selections/AB_tot_select_GLM.xlsx")

# Set the order of models
AB_tot_select_GLM$models <- paste0("m_", 1:nrow(AB_tot_select_GLM))
AB_tot_select_GLM$models = as.factor(AB_tot_select_GLM$models)

df = AB_tot_select_GLM
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")

# Find the best model based on RMSE
AB_tot_best_model_glm <- AB_tot_select_GLM %>%
  filter(RMSE == min(RMSE))

AB_tot_best_model_glm = AB_tot_select_GLM[AB_tot_select_GLM$models =="m_11",]
# cat ("The best model based on RMSE is: ")
# print(AB_tot_best_model_glm)






# Prepare data for facet plotting
AB_tot_select_GLM_long <- AB_tot_select_GLM %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

AB_tot_select_GLM_long$models <- forcats::fct_relevel(AB_tot_select_GLM_long$models, c(paste0("m_", 1:nrow(AB_tot_select_GLM)) ))

# Plot all metrics with shared x-axis
AB_tot_select_GLM_long$Response_variables = rep("Abundance (sqrt; ind./m²)")
g = ggplot(AB_tot_select_GLM_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "GLM: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 7)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_AB_tot_glm.png", plot = g, dpi = 300,height = 5.5,width = 9)

strings = AB_tot_select_GLM[11:nrow(AB_tot_select_GLM),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_AB_tot_GLM = cleaned_strings
b1 = predictor_non_r[!predictor_non_r %in% gsub("^\\d+_", "", AB_tot_select_GLM$delet)]
best_vars_AB_tot_GLM = c(best_vars_AB_tot_GLM,b1)
# for (i in best_vars_AB_tot_GLM){cat (paste0(i,sep=" + "))}
```

<p align="center">
<img src="Results/s_AB_tot_glm.png"/>
</p>

**The best model of GLM is :**

$mod_11 = glm(AB_tot ~ pet_sd_6 + tas_sd_6 + pr_mean_120 + P + Clay + \\ Sand + CN + pH + LC_, df = data)$

## Abundance: GAM

```{r reslt_gam_AB_tot, fig.align='center'}
AB_tot_select_GAM = read.xlsx("variables_selections/AB_tot_select_GAM.xlsx")


# Set the order of models
AB_tot_select_GAM$models = paste0("m_", 1:nrow(AB_tot_select_GAM))
AB_tot_select_GAM$models = as.factor(AB_tot_select_GAM$models)


df = AB_tot_select_GAM
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")


# Find the best model based on RMSE
AB_tot_best_model_gam <- AB_tot_select_GAM %>%
  filter(RMSE == min(RMSE))

AB_tot_best_model_gam = AB_tot_select_GAM[AB_tot_select_GAM$models =="m_7",]
# cat ("The best model based on RMSE is: ")
# print(AB_tot_best_model_gam)


# Prepare data for facet plotting
AB_tot_select_GAM_long <- AB_tot_select_GAM %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

AB_tot_select_GAM_long$models <- fct_relevel(AB_tot_select_GAM_long$models, c(paste0("m_", 1:nrow(AB_tot_select_GAM)) ))

# Plot all metrics with shared x-axis
AB_tot_select_GAM_long$Response_variables = rep("Abundance (sqrt; ind./m²)")
g = ggplot(AB_tot_select_GAM_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "gam: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 7)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_AB_tot_gam.png", plot = g, dpi = 300,height = 5.5,width = 9)

strings = AB_tot_select_GAM[7:nrow(AB_tot_select_GAM),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_AB_tot_GAM = cleaned_strings
b1 = predictor_non_r[!predictor_non_r %in% gsub("^\\d+_", "", AB_tot_select_GAM$delet)]
best_vars_AB_tot_GAM = c(best_vars_AB_tot_GAM,b1)
# for (i in best_vars_AB_tot_GAM){cat (paste0(i,sep=" + "))}
```

<p align="center">
<img src="Results/s_AB_tot_gam.png"/>
</p>

**The best model of gam is:**

$mod_7 = gam(AB_tot ~  tas_sd_6 + tas_sd_3 + Sand + tas_sd_120 +\\ K + pet_sd_6 + pH + CN + P + tas_mean_6 + pr_mean_3 + tas_mean_120 + LC_, df = data)$

## Abundance: RF

```{r reslt_rf_AB_tot, fig.align='center'}

AB_tot_select_RF = read.xlsx("variables_selections/AB_tot_select_RF.xlsx")

# Set the order of models
AB_tot_select_RF$models <-paste0("m_", 1:nrow(AB_tot_select_RF))
AB_tot_select_RF$models = as.factor(AB_tot_select_RF$models)


df = AB_tot_select_RF
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")

# Find the best model based on RMSE
AB_tot_best_model_rf <- AB_tot_select_RF %>%
  filter(RMSE == min(RMSE))

AB_tot_best_model_rf = AB_tot_select_RF[AB_tot_select_RF$models =="m_28",]
# cat ("The best model based on RMSE is: ")
# print(AB_tot_best_model_rf)


# Prepare data for facet plotting
AB_tot_select_RF_long <- AB_tot_select_RF %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

AB_tot_select_RF_long$models <- fct_relevel(AB_tot_select_RF_long$models, c(paste0("m_", 1:nrow(AB_tot_select_RF)) ))

# Plot all metrics with shared x-axis
AB_tot_select_RF_long$Response_variables = rep("Abundance (sqrt; ind./m²)")
g = ggplot(AB_tot_select_RF_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "RF: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 6)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_AB_tot_rf.png", plot = g, dpi = 300,height = 5.5,width = 13)

# for (i in predictor_deep){cat (paste0(i,sep=" + "))}

strings = AB_tot_select_RF[28:nrow(AB_tot_select_RF),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_AB_tot_RF = cleaned_strings
b1 = predictor_deep[!predictor_deep %in% gsub("^\\d+_", "", AB_tot_select_RF$delet)]
best_vars_AB_tot_RF = c(best_vars_AB_tot_RF,b1)
# for (i in best_vars_AB_tot_RF){cat (paste0(i,sep=" + "))}
```

<p align="center">
<img src="Results/s_AB_tot_rf.png"/>
</p>

**The best model of RF is:**

$mod_28 = rf(AB_tot ~ CN + pr_mean_6 + pet_mean_3 + K + tasmin_sd_6 + \\ tasmin_mean_120 + tasmin_mean_6 + Clay + pr_sd_120 + tas_mean_120 + CaCO3 + \\tas_sd_120 + pH + 4LC_ , df = data)$

## Abundance: GBM

```{r reslt_gbm_AB_tot, fig.align='center'}
AB_tot_select_GBM = read.xlsx("variables_selections/AB_tot_select_GBM.xlsx")

# Set the order of models
AB_tot_select_GBM$models <- paste0("m_", 1:nrow(AB_tot_select_GBM))
AB_tot_select_GBM$models = as.factor(AB_tot_select_GBM$models)


df = AB_tot_select_GBM
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")

# Find the best model based on RMSE
AB_tot_best_model_gbm <- AB_tot_select_GBM %>%
  filter(RMSE == min(RMSE))

AB_tot_best_model_gbm = AB_tot_select_GBM[AB_tot_select_GBM$models =="m_17",]
# cat ("The best model based on RMSE is: ")
# print(AB_tot_best_model_gbm)



# Prepare data for facet plotting
AB_tot_select_GBM_long <- AB_tot_select_GBM %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

AB_tot_select_GBM_long$models <- fct_relevel(AB_tot_select_GBM_long$models, c(paste0("m_", 1:nrow(AB_tot_select_GBM))))

# Plot all metrics with shared x-axis
AB_tot_select_GBM_long$Response_variables = rep("Abundance (sqrt; ind./m²)")
g = ggplot(AB_tot_select_GBM_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "GBM: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 6)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_AB_tot_gbm.png", plot = g, dpi = 300,height = 5.5,width = 13)

strings = AB_tot_select_GBM[17:nrow(AB_tot_select_GBM),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_AB_tot_GBM = cleaned_strings
b1 = predictor_deep[!predictor_deep %in% gsub("^\\d+_", "", AB_tot_select_GBM$delet)]
best_vars_AB_tot_GBM = c(best_vars_AB_tot_GBM,b1)
# for (i in best_vars_AB_tot_GBM){cat (paste0(i,sep=" + "))}
```

<p align="center">
<img src="Results/s_AB_tot_gbm.png"/>
</p>

**The best model of GBM is:**

$mod_17 = gbm(AB_tot ~ tasmin_sd_6 + tasmax_mean_6 + Sand + pr_mean_120 + tas_mean_6 +\\ pet_sd_3 + CaCO3 + tasmin_mean_120 + CN + K + tasmax_mean_120 + pet_sd_6 + pr_sd_6 +\\ P + Silt + tas_sd_6 + pr_mean_6 + pet_mean_3 + tasmin_mean_6 + pr_sd_120 + Clay + pH + \\ tas_mean_120 + pr_mean_3 + LC_, df = data)$

## Abundance: ANN

```{r reslt_ann_AB_tot, fig.align='center'}

AB_tot_select_ANN = read.xlsx("variables_selections/AB_tot_select_ANN.xlsx")

# Set the order of models
AB_tot_select_ANN$models <- paste0("m_", 1:nrow(AB_tot_select_ANN))
AB_tot_select_ANN$models = as.factor(AB_tot_select_ANN$models)


df = AB_tot_select_ANN
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")

# Find the best model based on RMSE
AB_tot_best_model_ann <- AB_tot_select_ANN %>%
  filter(RMSE == min(RMSE))

AB_tot_best_model_ann = AB_tot_select_ANN[AB_tot_select_ANN$models =="m_27",]
# cat ("The best model based on RMSE is: ")
# print(AB_tot_best_model_ann)



# Prepare data for facet plotting
AB_tot_select_ANN_long <- AB_tot_select_ANN %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

# AB_tot_select_ANN_long$models <- fct_relevel(AB_tot_select_ANN_long$models, c(levels(AB_tot_select_ANN$models) ))

# Plot all metrics with shared x-axis
AB_tot_select_ANN_long$Response_variables = rep("Abundance (sqrt; ind./m²)")
g = ggplot(AB_tot_select_ANN_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "ANN: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 6)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_AB_tot_ann.png", plot = g, dpi = 300,height = 5.5,width = 13)


strings = AB_tot_select_ANN[27:nrow(AB_tot_select_ANN),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_AB_tot_ANN = cleaned_strings
b1 = predictor_deep[!predictor_deep %in% gsub("^\\d+_", "", AB_tot_select_ANN$delet)]
best_vars_AB_tot_ANN = c(best_vars_AB_tot_ANN,b1)
# for (i in best_vars_AB_tot_ANN){cat (paste0(i,sep=" + "))}

```

<p align="center">
<img src="Results/s_AB_tot_ann.png"/>
</p>

**The best model of ANN is:**

$mod_27 = ann(AB_tot ~ pr_sd_6 + pH + P + pr_sd_120 + K + tasmin_sd_3 + \\ pet_sd_3 + pr_sd_3 + pet_mean_120 + tas_sd_120 + CaCO3 + Silt + tasmax_mean_120 + \\ tasmin_sd_120 + LC_ , df = data)$

## Abundance: best models

```{r best_model_AB_tot}
AB_tot_best_models = rbind(
AB_tot_best_model_glm,
AB_tot_best_model_gam,
AB_tot_best_model_rf,
AB_tot_best_model_gbm,
AB_tot_best_model_ann
)

AB_tot_best_models_best = AB_tot_best_models[AB_tot_best_models$Algorithms =="RF", ]
  
df = AB_tot_best_models
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )

df$Models = NULL
df$Delete = NULL
rownames(df) = NULL
df <- df %>%
  dplyr::rename(
    Models =Algo)

df$Models <- toupper(df$Models)
df$Rep.var = rep("Abundance")
df$R2_adj_train=NULL
# datatable(df, options = list(pageLength = 5))
kable(df)
# colMeans(df[,c(3:6)])
rm("df")

```

**Meta models**

```{r Meta model AB_tot, cache.rebuild=TRUE}
reslt_AB_tot_averaging = read.xlsx("Results/AB_tot_averaging.xlsx")
reslt_AB_tot_stacking = read.xlsx("Results/AB_tot_stacking.xlsx")
df = rbind(reslt_AB_tot_averaging,reslt_AB_tot_stacking)
df$R2_adj_train=NULL
kable(df)
```



<br/> **GLM**

$mod = glm(AB_tot ~ pet_sd_6 + tas_sd_6 + pr_mean_120 + P + Clay + \\ Sand + CN + pH + LC_, df = data)$

<br/> **GAM**

$mod = gam(AB_tot ~  tas_sd_6 + tas_sd_3 + Sand + tas_sd_120 +\\ K + pet_sd_6 + pH + CN + P + tas_mean_6 + pr_mean_3 + tas_mean_120 + LC_, df = data)$

<br/> **RF**

$mod = rf(AB_tot ~ CN + pr_mean_6 + pet_mean_3 + K + tasmin_sd_6 + \\ tasmin_mean_120 + tasmin_mean_6 + Clay + pr_sd_120 + tas_mean_120 + CaCO3 + \\tas_sd_120 + pH + 4LC_ , df = data)$

<br/> **GBM**

$mod= gbm(AB_tot ~ tasmin_sd_6 + tasmax_mean_6 + Sand + pr_mean_120 + tas_mean_6 +\\ pet_sd_3 + CaCO3 + tasmin_mean_120 + CN + K + tasmax_mean_120 + pet_sd_6 + pr_sd_6 +\\ P + Silt + tas_sd_6 + pr_mean_6 + pet_mean_3 + tasmin_mean_6 + pr_sd_120 + Clay + pH + \\ tas_mean_120 + pr_mean_3 + LC_, df = data)$

<br/> **ANN**

$mod = ann(AB_tot ~ pr_sd_6 + pH + P + pr_sd_120 + K + tasmin_sd_3 + \\ pet_sd_3 + pr_sd_3 + pet_mean_120 + tas_sd_120 + CaCO3 + Silt + tasmax_mean_120 + \\ tasmin_sd_120 + LC_ , df = data)$

<br/> <br/> **Conclusion: le meillleur model pour l'abondance est le RF**





# LandWorm results: total biomass

[Biomass: best models]


## Biomass: GLM

```{r reslt_glm_BM_tot, fig.align='center'}
BM_tot_select_GLM = read.xlsx("variables_selections/BM_tot_select_GLM.xlsx")

# Set the order of models
BM_tot_select_GLM$models <- paste0("m_", 1:nrow(BM_tot_select_GLM))
BM_tot_select_GLM$models = as.factor(BM_tot_select_GLM$models)

df = BM_tot_select_GLM
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")

# Find the best model based on RMSE
BM_tot_best_model_glm <- BM_tot_select_GLM %>%
  filter(RMSE == min(RMSE))

BM_tot_best_model_glm = BM_tot_select_GLM[BM_tot_select_GLM$models == "m_4", ]
# cat ("The best model based on RMSE is: ")
# print(BM_tot_best_model_glm)






# Prepare data for facet plotting
BM_tot_select_GLM_long <- BM_tot_select_GLM %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

BM_tot_select_GLM_long$models <- fct_relevel(BM_tot_select_GLM_long$models, c(paste0("m_", 1:nrow(BM_tot_select_GLM)) ))

# Plot all metrics with shared x-axis
BM_tot_select_GLM_long$Response_variables = rep("Biomass (sqrt; g /m²)")
g = ggplot(BM_tot_select_GLM_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "GLM: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 7)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_BM_tot_glm.png", plot = g, dpi = 300,height = 5.5,width = 9)

strings = BM_tot_select_GLM[4:nrow(BM_tot_select_GLM),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_BM_tot_GLM = cleaned_strings
b1 = predictor_non_r[!predictor_non_r %in% gsub("^\\d+_", "", BM_tot_select_GLM$delet)]
best_vars_BM_tot_GLM = c(best_vars_BM_tot_GLM,b1)
# for (i in best_vars_BM_tot_GLM){cat (paste0(i,sep=" + "))}

```

<p align="center">
<img src="Results/s_BM_tot_glm.png"/>
</p>

**The best model of GLM is :**

$mod_6 = glm(BM_tot ~ N + pet_mean_6 + pet_sd_6 + tas_sd_120 + P + Sand + \\ Clay + C_org + tas_sd_6 + tas_sd_3 + pr_sd_3 + CN + tas_mean_6 + pH + \\ pr_mean_120 + LC_, df = data)$

## Biomass: GAM

```{r reslt_gam_BM_tot, fig.align='center'}
BM_tot_select_GAM = read.xlsx("variables_selections/BM_tot_select_GAM.xlsx")
BM_tot_select_GAM$models = paste0("m_", 1:nrow(BM_tot_select_GAM))

# Set the order of models
BM_tot_select_GAM$models <-paste0("m_", 1:nrow(BM_tot_select_GAM))
BM_tot_select_GAM$models = as.factor(BM_tot_select_GAM$models)


df = BM_tot_select_GAM
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")


# Find the best model based on RMSE
BM_tot_best_model_gam <- BM_tot_select_GAM %>%
  filter(RMSE == min(RMSE))

BM_tot_best_model_gam = BM_tot_select_GAM[BM_tot_select_GAM$models =="m_5",]
# cat ("The best model based on RMSE is: ")
# print(BM_tot_best_model_gam)


# Prepare data for facet plotting
BM_tot_select_GAM_long <- BM_tot_select_GAM %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

BM_tot_select_GAM_long$models <- fct_relevel(BM_tot_select_GAM_long$models, c(paste0("m_", 1:nrow(BM_tot_select_GAM)) ))

# Plot all metrics with shared x-axis
BM_tot_select_GAM_long$Response_variables = rep("Biomass (sqrt; g/m²)")
g = ggplot(BM_tot_select_GAM_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "gam: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 7)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_BM_tot_gam.png", plot = g, dpi = 300,height = 5.5,width = 9)

strings = BM_tot_select_GAM[5:nrow(BM_tot_select_GAM),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_BM_tot_GAM = cleaned_strings
b1 = predictor_non_r[!predictor_non_r %in% gsub("^\\d+_", "", BM_tot_select_GAM$delet)]
best_vars_BM_tot_GAM = c(best_vars_BM_tot_GAM,b1)
# for (i in best_vars_BM_tot_GAM){cat (paste0(i,sep=" + "))}

```

<p align="center">
<img src="Results/s_BM_tot_gam.png"/>
</p>

**The best model of gam is:**

$mod_5 = gam(BM_tot ~ P + CN + K + C_org + Sand + tas_sd_3 + pet_sd_6 + pr_sd_3 + tas_sd_6 + tas_mean_120 + pr_mean_3 + pH + pr_mean_120 + LC_ + LC_ , df = data)$

## Biomass: RF

```{r reslt_rf_BM_tot, fig.align='center'}

BM_tot_select_RF = read.xlsx("variables_selections/BM_tot_select_RF.xlsx")

# Set the order of models
BM_tot_select_RF$models <- paste0("m_", 1:nrow(BM_tot_select_RF))
BM_tot_select_RF$models = as.factor(BM_tot_select_RF$models)


df = BM_tot_select_RF
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")

# Find the best model based on RMSE
BM_tot_best_model_rf <- BM_tot_select_RF %>%
  filter(RMSE == min(RMSE))

BM_tot_best_model_rf = BM_tot_select_RF[BM_tot_select_RF$models =="m_34",]
# cat ("The best model based on RMSE is: ")
# print(BM_tot_best_model_rf)


# Prepare data for facet plotting
BM_tot_select_RF_long <- BM_tot_select_RF %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

BM_tot_select_RF_long$models <- fct_relevel(BM_tot_select_RF_long$models, c(paste0("m_", 1:nrow(BM_tot_select_RF)) ))

# Plot all metrics with shared x-axis
BM_tot_select_RF_long$Response_variables = rep("Biomass (sqrt; g/m²)")
g = ggplot(BM_tot_select_RF_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "RF: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 6)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_BM_tot_rf.png", plot = g, dpi = 300,height = 5.5,width = 13)

strings = BM_tot_select_RF[34:nrow(BM_tot_select_RF),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_BM_tot_RF = cleaned_strings
b1 = predictor_deep[!predictor_deep %in% gsub("^\\d+_", "", BM_tot_select_RF$delet)]
best_vars_BM_tot_RF = c(best_vars_BM_tot_RF,b1)
# for (i in best_vars_BM_tot_RF){cat (paste0(i,sep=" + "))}


```

<p align="center">
<img src="Results/s_BM_tot_rf.png"/>
</p>

**The best model of RF is:**

$mod_34 = rf(BM_tot ~ pr_mean_120 + Sand + pH + pet_sd_120 + tasmax_sd_3 + LC_ + tasmin_sd_120 + pet_mean_3 , df = data)$

## Biomass: GBM

```{r reslt_gbm_BM_tot, fig.align='center'}
BM_tot_select_GBM = read.xlsx("variables_selections/BM_tot_select_GBM.xlsx")

# Set the order of models
BM_tot_select_GBM$models <- paste0("m_", 1:nrow(BM_tot_select_GBM))
BM_tot_select_GBM$models = as.factor(BM_tot_select_GBM$models)


df = BM_tot_select_GBM
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")

# Find the best model based on RMSE
BM_tot_best_model_gbm <- BM_tot_select_GBM %>%
  filter(RMSE == min(RMSE))

BM_tot_best_model_gbm = BM_tot_select_GBM[BM_tot_select_GBM$models =="m_25",]
# cat ("The best model based on RMSE is: ")
# print(BM_tot_best_model_gbm)



# Prepare data for facet plotting
BM_tot_select_GBM_long <- BM_tot_select_GBM %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

BM_tot_select_GBM_long$models <- fct_relevel(BM_tot_select_GBM_long$models, c(paste0("m_", 1:nrow(BM_tot_select_GBM))))

# Plot all metrics with shared x-axis
BM_tot_select_GBM_long$Response_variables = rep("Biomass (sqrt; g/m²)")
g = ggplot(BM_tot_select_GBM_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "GBM: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 6)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_BM_tot_gbm.png", plot = g, dpi = 300,height = 5.5,width = 13)

strings = BM_tot_select_GBM[25:nrow(BM_tot_select_GBM),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_BM_tot_GBM = cleaned_strings
b1 = predictor_deep[!predictor_deep %in% gsub("^\\d+_", "", BM_tot_select_GBM$delet)]
best_vars_BM_tot_GBM = c(best_vars_BM_tot_GBM,b1)
# for (i in best_vars_BM_tot_GBM){cat (paste0(i,sep=" + "))}

```

<p align="center">
<img src="Results/s_BM_tot_gbm.png"/>
</p>

**The best model of GBM is:**

$mod_25 = gbm(BM_tot ~ pr_mean_6 + pet_sd_6 + tasmax_sd_3 + tasmin_mean_120 + \\P + pr_mean_120 + pr_sd_3 + pH + pr_sd_120 + tasmax_sd_6 + pet_mean_3 + Silt + Sand +\\ tasmax_mean_6 + pr_mean_3 + LC_ + tasmin_sd_3 , df = data)$

## Biomass: ANN

```{r reslt_ann_BM_tot, fig.align='center'}

BM_tot_select_ANN = read.xlsx("variables_selections/BM_tot_select_ANN.xlsx")

# Set the order of models
BM_tot_select_ANN$models <-paste0("m_", 1:nrow(BM_tot_select_ANN))
BM_tot_select_ANN$models = as.factor(BM_tot_select_ANN$models)


df = BM_tot_select_ANN
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")

# Find the best model based on RMSE
BM_tot_best_model_ann <- BM_tot_select_ANN %>%
  filter(RMSE == min(RMSE))

BM_tot_best_model_ann = BM_tot_select_ANN [BM_tot_select_ANN$models =="m_15",]
# cat ("The best model based on RMSE is: ")
# print(BM_tot_best_model_ann)



# Prepare data for facet plotting
BM_tot_select_ANN_long <- BM_tot_select_ANN %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

BM_tot_select_ANN_long$models <- fct_relevel(BM_tot_select_ANN_long$models, c(paste0("m_", 1:nrow(BM_tot_select_ANN))))

# Plot all metrics with shared x-axis
BM_tot_select_ANN_long$Response_variables = rep("Biomass (sqrt; g/m²)")
g = ggplot(BM_tot_select_ANN_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "ANN: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 6)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_BM_tot_ann.png", plot = g, dpi = 300,height = 5.5,width = 13)

strings = BM_tot_select_ANN[15:nrow(BM_tot_select_ANN),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_BM_tot_ANN = cleaned_strings
b1 = predictor_deep[!predictor_deep %in% gsub("^\\d+_", "", BM_tot_select_ANN$delet)]
best_vars_BM_tot_ANN = c(best_vars_BM_tot_ANN,b1)
# for (i in best_vars_BM_tot_ANN){cat (paste0(i,sep=" + "))}

```

<p align="center">
<img src="Results/s_BM_tot_ann.png"/>
</p>

**The best model of ANN is:**

$mod_15 = ann(BM_tot ~ pr_mean_3 + tasmax_mean_120 + pet_mean_120 + pr_sd_6 + \\Sand + tasmin_sd_6 + pet_sd_120 + K + Silt + tasmax_mean_6 + tasmin_sd_3 +\\ pet_sd_6 + pet_mean_3 + tas_mean_6 + tasmax_mean_3 + P + C_org + CN + tas_sd_3 + pr_sd_3 + \\tasmin_sd_120 + pet_sd_3 + tasmin_mean_3 + pr_mean_6 + pr_mean_120 + pH + LC_, df = data)$

## Biomass: best models

```{r best_model_BM_tot}
BM_tot_best_models = rbind(
BM_tot_best_model_glm,
BM_tot_best_model_gam,
BM_tot_best_model_rf,
BM_tot_best_model_gbm,
BM_tot_best_model_ann
)

BM_tot_best_models_best = BM_tot_best_models[BM_tot_best_models$Algorithms =="RF",]

df = BM_tot_best_models
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )

df$Models = NULL
df$Delete = NULL
rownames(df) = NULL
df <- df %>%
  dplyr::rename(
    Models =Algo)

df$Models <- toupper(df$Models)
df$Rep.var = rep("Biomass")
df$R2_adj_train=NULL
# datatable(df, options = list(pageLength = 5))
kable(df)
rm("df")

```

**Meta models**

```{r Meta model BM_tot, cache.rebuild=TRUE}
reslt_BM_tot_averaging = read.xlsx("Results/BM_tot_averaging.xlsx")
reslt_BM_tot_stacking = read.xlsx("Results/BM_tot_stacking.xlsx")
df = rbind(reslt_BM_tot_averaging,reslt_BM_tot_stacking)
df$R2_adj_train=NULL
kable(df)
```

<br/> **GLM**

$mod = glm(BM_tot ~ N + pet_mean_6 + pet_sd_6 + tas_sd_120 + P + Sand + \\ Clay + C_org + tas_sd_6 + tas_sd_3 + pr_sd_3 + CN + tas_mean_6 + pH + \\ pr_mean_120 + LC_, df = data)$

<br/> **GAM**

$mod = gam(BM_tot ~ P + CN + K + C_org + Sand + tas_sd_3 + pet_sd_6 + pr_sd_3 + tas_sd_6 + tas_mean_120 + pr_mean_3 + pH + pr_mean_120 + LC_ + LC_ , df = data)$

<br/> **RF**

$mod = rf(BM_tot ~ pr_mean_120 + Sand + pH + pet_sd_120 + tasmax_sd_3 + LC_ + tasmin_sd_120 + pet_mean_3 , df = data)$

<br/> **GBM**

$mod= gbm(BM_tot ~ pr_mean_6 + pet_sd_6 + tasmax_sd_3 + tasmin_mean_120 + \\P + pr_mean_120 + pr_sd_3 + pH + pr_sd_120 + tasmax_sd_6 + pet_mean_3 + Silt + Sand +\\ tasmax_mean_6 + pr_mean_3 + LC_ + tasmin_sd_3 , df = data)$

<br/> **ANN**

$mod = ann(BM_tot ~ pr_mean_3 + tasmax_mean_120 + pet_mean_120 + pr_sd_6 + \\Sand + tasmin_sd_6 + pet_sd_120 + K + Silt + tasmax_mean_6 + tasmin_sd_3 +\\ pet_sd_6 + pet_mean_3 + tas_mean_6 + tasmax_mean_3 + P + C_org + CN + tas_sd_3 + pr_sd_3 + \\tasmin_sd_120 + pet_sd_3 + tasmin_mean_3 + pr_mean_6 + pr_mean_120 + pH + LC_, df = data)$

<br/> <br/> **Conclusion: le meillleur model pour la biomasse est le RF**

# LandWorm results: total Richness

[Richness: best models]


## Richness: GLM

```{r reslt_glm_Richesse, fig.align='center'}
Richesse_tot_select_GLM = read.xlsx("variables_selections/Richesse_tot_select_GLM.xlsx")

# Set the order of models
Richesse_tot_select_GLM$models <-paste0("m_", 1:nrow(Richesse_tot_select_GLM))
Richesse_tot_select_GLM$models = as.factor(Richesse_tot_select_GLM$models)

df = Richesse_tot_select_GLM
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")

# Find the best model based on RMSE
Richesse_best_model_glm <- Richesse_tot_select_GLM %>%
  filter(RMSE == min(RMSE))

Richesse_best_model_glm = Richesse_tot_select_GLM[Richesse_tot_select_GLM$models =="m_7",]
# cat ("The best model based on RMSE is: ")
# print(Richesse_best_model_glm)






# Prepare data for facet plotting
Richesse_tot_select_GLM_long <- Richesse_tot_select_GLM %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

Richesse_tot_select_GLM_long$models <- fct_relevel(Richesse_tot_select_GLM_long$models, c(paste0("m_", 1:nrow(Richesse_tot_select_GLM)) ))

# Plot all metrics with shared x-axis
Richesse_tot_select_GLM_long$Response_variables = rep("Richness (nb. sp. /plot)")
g = ggplot(Richesse_tot_select_GLM_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "GLM: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 7)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_Richesse_glm.png", plot = g, dpi = 300,height = 5.5,width = 9)

strings = Richesse_tot_select_GLM[7:nrow(Richesse_tot_select_GLM),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_Richesse_tot_GLM = cleaned_strings
b1 = predictor_non_r[!predictor_non_r %in% gsub("^\\d+_", "", Richesse_tot_select_GLM$delet)]
best_vars_Richesse_tot_GLM = c(best_vars_Richesse_tot_GLM,b1)
# for (i in best_vars_Richesse_tot_GLM){cat (paste0(i,sep=" + "))}

```

<p align="center">
<img src="Results/s_Richesse_glm.png"/>
</p>

**The best model of GLM is :**

$mod_7 = glm(Richesse_tot ~ N + pr_sd_3 + tas_mean_120 + CN + P + tas_sd_6 + pet_sd_6 + pet_mean_6 + tas_mean_6 + tas_sd_120 + pr_mean_120 + pH + LC_, df = data)$

## Richness: GAM

```{r reslt_gam_Richesse, fig.align='center'}
Richesse_tot_select_GAM = read.xlsx("variables_selections/Richesse_tot_select_GAM.xlsx")
Richesse_tot_select_GAM$models = paste0("m_", 1:nrow(Richesse_tot_select_GAM))

# Set the order of models
Richesse_tot_select_GAM$models <- paste0("m_", 1:nrow(Richesse_tot_select_GAM))
Richesse_tot_select_GAM$models = as.factor(Richesse_tot_select_GAM$models)


df = Richesse_tot_select_GAM
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")


# Find the best model based on RMSE
Richesse_best_model_gam <- Richesse_tot_select_GAM %>%
  filter(RMSE == min(RMSE))

Richesse_best_model_gam = Richesse_tot_select_GAM[Richesse_tot_select_GAM$models =="m_4",]
# cat ("The best model based on RMSE is: ")
# print(Richesse_best_model_gam)


# Prepare data for facet plotting
Richesse_tot_select_GAM_long <- Richesse_tot_select_GAM %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

Richesse_tot_select_GAM_long$models <- fct_relevel(Richesse_tot_select_GAM_long$models, c(paste0("m_", 1:nrow(Richesse_tot_select_GAM)) ))

# Plot all metrics with shared x-axis
Richesse_tot_select_GAM_long$Response_variables = rep("Richness (nb. sp. /plot)")
g = ggplot(Richesse_tot_select_GAM_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "gam: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 7)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_Richesse_gam.png", plot = g, dpi = 300,height = 5.5,width = 9)

strings = Richesse_tot_select_GAM[4:nrow(Richesse_tot_select_GAM),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_Richesse_tot_GAM = cleaned_strings
b1 = predictor_non_r[!predictor_non_r %in% gsub("^\\d+_", "", Richesse_tot_select_GAM$delet)]
best_vars_Richesse_tot_GAM = c(best_vars_Richesse_tot_GAM,b1)
# for (i in best_vars_Richesse_tot_GAM){cat (paste0(i,sep=" + "))}

```

<p align="center">
<img src="Results/s_Richesse_gam.png"/>
</p>

**The best model of gam is:**

$mod_4 = gam(Richesse_tot ~ Sand + K + pr_sd_3 + tas_sd_3 + CN + tas_sd_120 +\\ P + tas_sd_6 + tas_mean_120 + pet_sd_6 + pet_mean_6 + N + tas_mean_6 + pr_mean_120 +\\ pH + LC_ , df = data)$

## Richness: RF

```{r reslt_rf_Richesse, fig.align='center'}

Richesse_tot_select_RF = read.xlsx("variables_selections/Richesse_tot_select_RF.xlsx")

# Set the order of models
Richesse_tot_select_RF$models <-paste0("m_", 1:nrow(Richesse_tot_select_RF))
Richesse_tot_select_RF$models = as.factor(Richesse_tot_select_RF$models)


df = Richesse_tot_select_RF
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")

# Find the best model based on RMSE
Richesse_best_model_rf <- Richesse_tot_select_RF %>%
  filter(RMSE == min(RMSE))

Richesse_best_model_rf = Richesse_tot_select_RF[Richesse_tot_select_RF$models =="m_24",]
# cat ("The best model based on RMSE is: ")
# print(Richesse_best_model_rf)


# Prepare data for facet plotting
Richesse_tot_select_RF_long <- Richesse_tot_select_RF %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

Richesse_tot_select_RF_long$models <- fct_relevel(Richesse_tot_select_RF_long$models, c(paste0("m_", 1:nrow(Richesse_tot_select_RF)) ))

# Plot all metrics with shared x-axis
Richesse_tot_select_RF_long$Response_variables = rep("Richness (nb. sp. /plot)")
g = ggplot(Richesse_tot_select_RF_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "RF: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 6)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_Richesse_rf.png", plot = g, dpi = 300,height = 5.5,width = 13)

strings = Richesse_tot_select_RF[24:nrow(Richesse_tot_select_RF),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_Richesse_tot_RF = cleaned_strings
b1 = predictor_deep[!predictor_deep %in% gsub("^\\d+_", "", Richesse_tot_select_RF$delet)]
best_vars_Richesse_tot_RF = c(best_vars_Richesse_tot_RF,b1)
# for (i in best_vars_Richesse_tot_RF){cat (paste0(i,sep=" + "))}

```

<p align="center">
<img src="Results/s_Richesse_rf.png"/>
</p>

**The best model of RF is:**

$mod_24 = rf(Richesse_tot ~ pr_sd_3 + tasmin_sd_120 + pr_sd_120 + tasmin_sd_6 + K + tas_mean_120 + pr_mean_6 + Silt + P + CaCO3 + pr_mean_120 + tasmax_sd_3 + tas_sd_6 + tas_sd_120 + tasmax_sd_120 + pH + pet_sd_120 + LC_, df = data)$

## Richness: GBM

```{r reslt_gbm_Richesse, fig.align='center'}
Richesse_tot_select_GBM = read.xlsx("variables_selections/Richesse_tot_select_GBM.xlsx")

# Set the order of models
Richesse_tot_select_GBM$models <- paste0("m_", 1:nrow(Richesse_tot_select_GBM))
Richesse_tot_select_GBM$models = as.factor(Richesse_tot_select_GBM$models)


df = Richesse_tot_select_GBM
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")

# Find the best model based on RMSE
Richesse_best_model_gbm <- Richesse_tot_select_GBM %>%
  filter(RMSE == min(RMSE))

Richesse_best_model_gbm = Richesse_tot_select_GBM[Richesse_tot_select_GBM$models =="m_24",]
# cat ("The best model based on RMSE is: ")
# print(Richesse_best_model_gbm)



# Prepare data for facet plotting
Richesse_tot_select_GBM_long <- Richesse_tot_select_GBM %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

Richesse_tot_select_GBM_long$models <- fct_relevel(Richesse_tot_select_GBM_long$models, c(paste0("m_", 1:nrow(Richesse_tot_select_GBM)) ))

# Plot all metrics with shared x-axis
Richesse_tot_select_GBM_long$Response_variables = rep("Richness (nb. sp. /plot)")
g = ggplot(Richesse_tot_select_GBM_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "GBM: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 6)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_Richesse_gbm.png", plot = g, dpi = 300,height = 5.5,width = 13)

strings = Richesse_tot_select_GBM[24:nrow(Richesse_tot_select_GBM),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_Richesse_tot_GBM = cleaned_strings
b1 = predictor_deep[!predictor_deep %in% gsub("^\\d+_", "", Richesse_tot_select_GBM$delet)]
best_vars_Richesse_tot_GBM = c(best_vars_Richesse_tot_GBM,b1)
# for (i in best_vars_Richesse_tot_GBM){cat (paste0(i,sep=" + "))}

```

<p align="center">
<img src="Results/s_Richesse_gbm.png"/>
</p>

**The best model of GBM is:**

$mod_9 = gbm(Richesse_tot ~ pr_mean_3 + Clay + tasmax_mean_6 + pr_mean_120 + tasmax_sd_120 + tasmin_sd_6 + CaCO3 + pr_sd_6 + N + K + pr_mean_6 + pr_sd_120 + Sand + tasmin_sd_3 + P + pH + pet_sd_120 + LC_, df = data)$

## Richness: ANN

```{r reslt_ann_Richesse, fig.align='center'}

Richesse_tot_select_ANN = read.xlsx("variables_selections/Richesse_tot_select_ANN.xlsx")

# Set the order of models
Richesse_tot_select_ANN$models <- paste0("m_", 1:nrow(Richesse_tot_select_ANN))
Richesse_tot_select_ANN$models = as.factor(Richesse_tot_select_ANN$models)


df = Richesse_tot_select_ANN
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )
df$Algo = NULL
df$Rep.var = NULL
rownames(df) = NULL
datatable(df, options = list(pageLength = 5))
rm("df")

# Find the best model based on RMSE
Richesse_best_model_ann <- Richesse_tot_select_ANN %>%
  filter(RMSE == min(RMSE))

Richesse_best_model_ann = Richesse_tot_select_ANN[Richesse_tot_select_ANN$models == "m_33",]
# Richesse_best_model_ann = Richesse_tot_select_ANN
# cat ("The best model based on RMSE is: ")
# print(Richesse_best_model_ann)



# Prepare data for facet plotting
Richesse_tot_select_ANN_long <- Richesse_tot_select_ANN %>%
  pivot_longer(cols = c(R2_adjusted_train, R2_test, RMSE, MAE), 
               names_to = "metric", 
               values_to = "value")

Richesse_tot_select_ANN_long$models <- fct_relevel(Richesse_tot_select_ANN_long$models, c(paste0("m_", 1:nrow(Richesse_tot_select_ANN)) ))

# Plot all metrics with shared x-axis
Richesse_tot_select_ANN_long$Response_variables = rep("Richness (nb. sp. /plot)")
g = ggplot(Richesse_tot_select_ANN_long, aes(x = models, y = value, fill = Response_variables), color = "black") +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(
    metric = c(
      R2_adjusted_train = "R² adjusted (train)",
      R2_test = "R² (test)",
      RMSE = "RMSE",
      MAE = "MAE"
    )
  )) +
  theme_minimal() +
  labs(title = "ANN: performance metrics of different models",
       x = "Models",
       y = "Values") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 6)) + 
  scale_x_discrete(drop = FALSE) +
  scale_fill_manual(values = "gray")


ggsave("Results/s_Richesse_ann.png", plot = g, dpi = 300,height = 5.5,width = 13)

strings = Richesse_tot_select_ANN[33:nrow(Richesse_tot_select_ANN),"delet"]
cleaned_strings <- gsub("^\\d+_", "", strings)
best_vars_Richesse_tot_ANN = cleaned_strings
b1 = predictor_deep[!predictor_deep %in% gsub("^\\d+_", "", Richesse_tot_select_ANN$delet)]
best_vars_Richesse_tot_ANN = c(best_vars_Richesse_tot_ANN,b1)
# for (i in best_vars_Richesse_tot_ANN){cat (paste0(i,sep=" + "))}

```

<p align="center">
<img src="Results/s_Richesse_ann.png"/>
</p>

**The best model of ANN is:**

$mod_33 = ann(Richesse_tot ~ P + tasmin_sd_120 + pr_sd_3 + tasmin_sd_3 + pr_sd_120 + pr_mean_6 + Silt + pH + LC_, df = data)$

## Richness: best models

```{r best_model_Richesse}
Richesse_best_models = rbind(
Richesse_best_model_glm,
Richesse_best_model_gam,
Richesse_best_model_rf,
Richesse_best_model_gbm,
Richesse_best_model_ann
)

Richesse_best_models_best = Richesse_best_models[Richesse_best_models$Algorithms=="RF",]
df = Richesse_best_models
  
df <- df %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )

df$Models = NULL
df$Delete = NULL
rownames(df) = NULL
df <- df %>%
  dplyr::rename(
    Models =Algo)

df$Models <- toupper(df$Models)
df$Rep.var = rep("Richness")
df$R2_adj_train=NULL
# datatable(df, options = list(pageLength = 5))
kable(df)
rm("df")

```

**Meta models**

```{r Meta model Richesse_tot}
reslt_Richesse_tot_averaging = read.xlsx("Results/Richesse_tot_averaging.xlsx")
reslt_Richesse_tot_stacking = read.xlsx("Results/Richesse_tot_stacking.xlsx")
df = rbind(reslt_Richesse_tot_averaging,reslt_Richesse_tot_stacking)
df$R2_adj_train=NULL
kable(df)
```


<br/> **GLM**

$mod = glm(Richesse_tot ~ N + pr_sd_3 + tas_mean_120 + CN + P + tas_sd_6 + pet_sd_6 + pet_mean_6 + tas_mean_6 + tas_sd_120 + pr_mean_120 + pH + LC_, df = data)$

<br/> **GAM**

$mod =  gam(BM_tot ~ P + CN + K + C_org + Sand + tas_sd_3 + pet_sd_6 + pr_sd_3 + tas_sd_6 + tas_mean_120 + pr_mean_3 + pH + pr_mean_120 + LC_ + LC_ , df = data)$

<br/> **RF**

$mod = rf(Richesse_tot ~ pr_sd_3 + tasmin_sd_120 + pr_sd_120 + tasmin_sd_6 + K + tas_mean_120 + pr_mean_6 + Silt + P + CaCO3 + pr_mean_120 + tasmax_sd_3 + tas_sd_6 + tas_sd_120 + tasmax_sd_120 + pH + pet_sd_120 + LC_, df = data)$

<br/> **GBM**

$mod= gbm(Richesse_tot ~ pr_mean_3 + Clay + tasmax_mean_6 + pr_mean_120 + tasmax_sd_120 + tasmin_sd_6 + CaCO3 + pr_sd_6 + N + K + pr_mean_6 + pr_sd_120 + Sand + tasmin_sd_3 + P + pH + pet_sd_120 + LC_, df = data)$

<br/> **ANN**

$mod = ann(Richesse_tot ~ P + tasmin_sd_120 + pr_sd_3 + tasmin_sd_3 + pr_sd_120 + pr_mean_6 + Silt + pH + LC_, df = data)$

<br/> <br/> **Conclusion: le meillleur model pour la Richesse_tot est le RF**





# Best of the best models

## Performances

```{r}
best_models = rbind(
AB_tot_best_models_best,
BM_tot_best_models_best,
Richesse_best_models_best
)


df <- best_models %>%
  dplyr::rename(
    Algo =Algorithms ,
     Rep.var = Response_variables,
     R2_adj_train = R2_adjusted_train,
    Delete = delet,
    Models = models
  )

df$Models = NULL
df$Delete = NULL
rownames(df) = NULL
df <- df %>%
  dplyr::rename(
    Models =Algo)

df$Models <- toupper(df$Models)
df$Rep.var = c("Abundance", "Biomass","Richness")
# datatable(df, options = list(pageLength = 5))
kable(df)
stock_df = df
rm("df")



```

## Models

<br/> **Abundance**

$mod = rf(AB_tot ~ CN + pr_mean_6 + pet_mean_3 + K + tasmin_sd_6 + \\ tasmin_mean_120 + tasmin_mean_6 + Clay + pr_sd_120 + tas_mean_120 + CaCO3 + \\tas_sd_120 + pH + 4LC_ , df = data)$

<br/> **Biomass**

$mod = rf(BM_tot ~ pr_mean_120 + Sand + pH + pet_sd_120 + tasmax_sd_3 + \\ LC_ + tasmin_sd_120 + pet_mean_3 , df = data)$

<br/> **Richness**

$mod = rf(Richesse_tot ~ pr_sd_3 + tasmin_sd_120 + pr_sd_120 + tasmin_sd_6 +\\ K + tas_mean_120 + pr_mean_6 + Silt + P + CaCO3 + pr_mean_120 + tasmax_sd_3 +\\ tas_sd_6 + tas_sd_120 + tasmax_sd_120 + pH + pet_sd_120 + LC_, df = data)$

## Optimisation des bests models

<br/> **____________Befor_____________**

```{r}
kable(stock_df)
```

<br/>

**____________After_____________**

```{r optimisation AB_tot,eval=TRUE}
#
AB_tot_RF_tuning = read.csv2("results_tuning/AB_tot_RF_tuning.csv")


AB_tot_RF_tuning = as.data.frame(AB_tot_RF_tuning)
AB_tot_RF_tuning = AB_tot_RF_tuning %>% arrange(rmse)
# head(AB_tot_RF_tuning)

AB_tot_best_param = AB_tot_RF_tuning[1,]

# plot(seq(1:nrow(AB_tot_RF_tuning)), AB_tot_RF_tuning$r_squared)
# Best hyperparameter values
AB_tot_best_mtry = AB_tot_best_param$mtry
AB_tot_best_ntree = AB_tot_best_param$ntree
AB_tot_best_maxnodes = AB_tot_best_param$maxnode

  
best_vars_AB_tot = best_vars_AB_tot_RF

RF_result_AB_tot = ForetAlea(var_rep ="AB_tot", 
                            df_app= AB_tot_train [, c("AB_tot", best_vars_AB_tot)], 
                            df_valid = AB_tot_test [, c("AB_tot", best_vars_AB_tot)],
                             mtry = 3,
                             ntree= 500,
                             maxnodes = NULL)

# summary(RF_result_AB_tot$predit)
# summary(AB_tot_test$AB_tot)
# RF_result_AB_tot$df

new_stock_df = stock_df
new_stock_df[new_stock_df$Rep.var == "Abundance",] = c("RF","Abundance",
                                                       RF_result_AB_tot$R_adj_train,
                                                        RF_result_AB_tot$R_adj_test,
                                                       RF_result_AB_tot$RMSE,
                                                       RF_result_AB_tot$MAE)
# kable(new_stock_df)

saveRDS(RF_result_AB_tot$model, "cartographie/best_mod/RF_mod_AB_tot.RDS")

```

```{r optimisation BM_tot ,eval=TRUE}
#
BM_tot_RF_tuning = read.csv2("results_tuning/BM_tot_RF_tuning.csv")


BM_tot_RF_tuning = as.data.frame(BM_tot_RF_tuning)
BM_tot_RF_tuning = BM_tot_RF_tuning %>% arrange(rmse)
# head(BM_tot_RF_tuning)

BM_tot_best_param = BM_tot_RF_tuning[1,]

# plot(seq(1:nrow(BM_tot_RF_tuning)), BM_tot_RF_tuning$r_squared)
# Best hyperparameter values
BM_tot_best_mtry = BM_tot_best_param$mtry
BM_tot_best_ntree = BM_tot_best_param$ntree
BM_tot_best_maxnodes = BM_tot_best_param$maxnode

  
best_vars_BM_tot = best_vars_BM_tot_RF

RF_result_BM_tot = ForetAlea(var_rep ="BM_tot", 
                            df_app= BM_tot_train [, c("BM_tot", best_vars_BM_tot)], 
                            df_valid = BM_tot_test [, c("BM_tot", best_vars_BM_tot)],
                             mtry = 3,
                             ntree= 500,
                             maxnodes = NULL)

# summary(RF_result_BM_tot$predit)
# summary(BM_tot_test$BM_tot)
# RF_result_BM_tot$df


new_stock_df[new_stock_df$Rep.var == "Biomass",] = c("RF","Biomass",
                                                       RF_result_BM_tot$R_adj_train,
                                                        RF_result_BM_tot$R_adj_test,
                                                       RF_result_BM_tot$RMSE,
                                                       RF_result_BM_tot$MAE)
# kable(new_stock_df)
saveRDS(RF_result_BM_tot$model, "cartographie/best_mod/RF_mod_BM_tot.RDS")
```



```{r optimisation Richesse_tot ,eval=TRUE}

#
Richesse_RF_tuning = read.csv2("results_tuning/Richesse_tot_RF_tuning.csv")


Richesse_RF_tuning = as.data.frame(Richesse_RF_tuning)
Richesse_RF_tuning = Richesse_RF_tuning %>% arrange(rmse)
# head(Richesse_RF_tuning)

Richesse_best_param = Richesse_RF_tuning[1,]

# plot(seq(1:nrow(Richesse_RF_tuning)), Richesse_RF_tuning$r_squared)
# Best hyperparameter values
Richesse_best_mtry = Richesse_best_param$mtry
Richesse_best_ntree = Richesse_best_param$ntree
Richesse_best_maxnodes = Richesse_best_param$maxnode

  
best_vars_Richesse = best_vars_Richesse_tot_RF

RF_result_Richesse_tot = ForetAlea(var_rep ="Richesse_tot", 
                  df_app= Richesse_tot_train [, c("Richesse_tot", best_vars_Richesse)], 
                df_valid = Richesse_tot_test [, c("Richesse_tot", best_vars_Richesse)],
                             mtry = 4,
                             ntree= 500,
                             maxnodes = NULL)

# summary(RF_result_Richesse_tot$predit)
# summary(Richesse_tot_test$Richesse_tot)
# RF_result_Richesse_tot$df


new_stock_df[new_stock_df$Rep.var == "Richness",] = c("RF","Richness",
                                                       RF_result_Richesse_tot$R_adj_train,
                                                        RF_result_Richesse_tot$R_adj_test,
                                                       RF_result_Richesse_tot$RMSE,
                                                       RF_result_Richesse_tot$MAE)
kable(new_stock_df)
saveRDS(RF_result_Richesse_tot$model, "cartographie/best_mod/RF_mod_Richesse_tot.RDS")
```

## Graphes

```{r obs vs pred}
# summary(RF_result_AB_tot$predit)
# summary(AB_tot_test$AB_tot)
p_size =0.5
RF_df_AB_tot = data.frame(Observed = AB_tot_test$AB_tot,
                          Predicted = RF_result_AB_tot$predit)

g1 <- ggplot(RF_df_AB_tot, aes(x = Observed, y = Predicted)) +
      geom_point(size = p_size) + # Ajout des points
      geom_smooth(method = "lm", se = TRUE, color = "red") + 
      labs(subtitle =paste0(
        "Abundance (ind./m²)",
                           "\nR² = ", round(RF_result_AB_tot$R_adj_test,2),
                           "; RMSE = ",  round(RF_result_AB_tot$RMSE,2)),
                            x = " ",
                            y = " "
        ) + 
      theme_classic() +
      scale_x_continuous(breaks = c(seq(from =0, to =25, by = 5))) + 
      scale_y_continuous(breaks = c(seq(from =0, to =25, by = 5)))



RF_df_BM_tot = data.frame(Observed = BM_tot_test$BM_tot,
                          Predicted = RF_result_BM_tot$predit)

g2 <- ggplot(RF_df_BM_tot, aes(x = Observed, y = Predicted)) +
      geom_point(size = p_size) + # Ajout des points
      geom_smooth(method = "lm", se = TRUE, color = "red") + 
      labs(subtitle =paste0(
         "Biomass (g/m²)",
                           "\nR² = ", round(RF_result_BM_tot$R_adj_test,2),
                           "; RMSE = ",  round(RF_result_BM_tot$RMSE,2)),
                            x = " ",
                            y = " "
         ) + 
      theme_classic() +
      scale_x_continuous(breaks = c(seq(from =0, to =15, by = 3))) + 
      scale_y_continuous(breaks = c(seq(from =0, to =15, by = 3)))

RF_df_Richesse_tot = data.frame(Observed = Richesse_tot_test$Richesse_tot,
                          Predicted = round(RF_result_Richesse_tot$predit))
# nrow(df_mod_Richesse_tot[Richesse_tot_train$Richesse_tot>11,])
g3 <- ggplot(RF_df_Richesse_tot, aes(x = Observed, y = Predicted)) +
      geom_point(size = p_size) + # Ajout des points
      geom_smooth(method = "lm", se = TRUE, color = "red") + 
      labs(subtitle =paste0(
        "Richness (nr. of spp.)",
                           "\nR² = ", round(RF_result_Richesse_tot$R_adj_test,2),
                           "; RMSE = ",  round(RF_result_Richesse_tot$RMSE,2)),
                            x = " ",
                            y = " "
        ) + 
      theme_classic() +
      scale_x_continuous(breaks = c(seq(from =0, to =10, by = 2.5))) + 
      scale_y_continuous(breaks = c(seq(from =0, to =10, by = 2.5)))


figure <- ggpubr::ggarrange(g1, g2, g3,
                                    labels = c('(a)', '(b)', '(c)'), ncol = 3,
                                    common.legend = TRUE, legend = 'right')


figure = annotate_figure(figure,

                bottom = text_grob("Observed values", color = "black",
                                   vjust = 0, face = "bold", size = 10),
                left = text_grob("Predicted values", color = "black", rot = 90),)

# figure
ggsave("Results/landW/best_algo_RF_rapport.png", plot = figure, dpi = 300,height = 3,width = 7)

```

<p align="center">
  <img src="Results/landW/best_algo_RF_rapport.png">
</p>


## Comparaison


<p align="center">
  <img src="reslt_cop_inter_now.png">
</p>



# Importance des variables



## Abundance

::: {.panel-tabset}

## Predictors importances


```{r AB_tot importance,fig.align='center', eval=TRUE}
# best_vars_AB_tot_RF
AB_tot_df = landworm_explo_non_t[,c("AB_tot",best_vars_AB_tot_RF)]
# names(AB_tot_df)
AB_tot_df = drop_na(AB_tot_df)


rf <- randomForest(AB_tot ~ ., data = AB_tot_df)
# rf <- glm(AB_tot ~ ., data = AB_tot_df, family = 'gaussian')

# Utilisation du conteneur iml Predictor()
X <- AB_tot_df[which(names(AB_tot_df) != "AB_tot")]
predictor <- Predictor$new(rf, data = X, y = AB_tot_df$AB_tot)

set.seed(0012)
imp_AB_tot <- FeatureImp$new(predictor, loss = "rmse") 
# imp_AB_tot <- FeatureImp$new(predictor, loss = "mse") # mean squared error
plot(imp_AB_tot)

# Importance des fonctionnalités
# On calcule l'importance de chaque caractéristique pour les prédictions avec FeatureImp. La mesure de l'importance des fonctionnalités fonctionne en mélangeant chaque fonctionnalité et en mesurant l'ampleur de la baisse des performances. Pour cette tâche de régression, nous choisissons de mesurer la perte de performance avec l'erreur absolue moyenne (« mae »), un autre choix serait l'erreur quadratique moyenne (« mse »).

# https://christophm.github.io/interpretable-ml-book/feature-importance.html

```


## Predictors effects


```{r AB_tot effets, eval=TRUE}
# Effets de fonctionnalités
# Les effets locaux accumulés décrivent comment les predicteurs influencent en moyenne la prédiction d'un modèle d'apprentissage automatique: ALE montre comment la prédiction change localement, lorsque les predicteurs varie. Les marques sur l'axe des x indiquent la distribution des predicteurs, montrant la pertinence d'une région pour l'interprétation (peu ou pas de points signifie que nous ne devons pas surinterpréter cette région).

# ale <- FeatureEffect$new(predictor, feature = "gps_x") # uniquement lstat
# ale$plot()
# ale$set.feature("rm")
# ale$plot()
effs <- FeatureEffects$new(predictor) # toutes les variables
plot(effs)

```


## Predictors interactions


```{r AB_tot interaction , eval=TRUE}

# Mesurer les interactions
# Nous pouvons également mesurer la force avec laquelle les fonctionnalités interagissent les unes avec les autres. La mesure d'interaction concerne la part de la variance de F(X) s’explique par l’interaction. La mesure est comprise entre 0 (pas d'interaction) et 1 (= 100 % de variance deF(X) en raison des interactions). Pour chaque fonctionnalité, nous mesurons dans quelle mesure elles interagissent avec toute autre fonctionnalité.
interact <- Interaction$new(predictor)
plot(interact)
# cat("Predictor interactions: Land use")
# interact <- Interaction$new(predictor, feature = "LC_")
# plot(interact)

```

:::

## Biomass

::: {.panel-tabset}

## Predictors importances


```{r BM_tot importance,fig.align='center', eval=TRUE}
# best_vars_BM_tot_RF
BM_tot_df = landworm_explo_non_t[,c("BM_tot",best_vars_BM_tot_RF)]
# names(BM_tot_df)
BM_tot_df = drop_na(BM_tot_df)


rf <- randomForest(BM_tot ~ ., data = BM_tot_df)
# rf <- glm(BM_tot ~ ., data = BM_tot_df, family = 'gaussian')

# Utilisation du conteneur iml Predictor()
X <- BM_tot_df[which(names(BM_tot_df) != "BM_tot")]
predictor <- Predictor$new(rf, data = X, y = BM_tot_df$BM_tot)

set.seed(0012)
imp_BM_tot <- FeatureImp$new(predictor, loss = "rmse") 
# imp_BM_tot <- FeatureImp$new(predictor, loss = "mse") # mean squared error
plot(imp_BM_tot)

# Importance des fonctionnalités
# On calcule l'importance de chaque caractéristique pour les prédictions avec FeatureImp. La mesure de l'importance des fonctionnalités fonctionne en mélangeant chaque fonctionnalité et en mesurant l'ampleur de la baisse des performances. Pour cette tâche de régression, nous choisissons de mesurer la perte de performance avec l'erreur absolue moyenne (« mae »), un autre choix serait l'erreur quadratique moyenne (« mse »).

# https://christophm.github.io/interpretable-ml-book/feature-importance.html

```


## Predictors effects


```{r BM_tot effets, eval=TRUE}
# Effets de fonctionnalités
# Les effets locaux accumulés décrivent comment les predicteurs influencent en moyenne la prédiction d'un modèle d'apprentissage automatique: ALE montre comment la prédiction change localement, lorsque les predicteurs varie. Les marques sur l'axe des x indiquent la distribution des predicteurs, montrant la pertinence d'une région pour l'interprétation (peu ou pas de points signifie que nous ne devons pas surinterpréter cette région).

# ale <- FeatureEffect$new(predictor, feature = "gps_x") # uniquement lstat
# ale$plot()
# ale$set.feature("rm")
# ale$plot()
effs <- FeatureEffects$new(predictor) # toutes les variables
plot(effs)

```


## Predictors interactions


```{r BM_tot interaction , eval=TRUE}

# Mesurer les interactions
# Nous pouvons également mesurer la force avec laquelle les fonctionnalités interagissent les unes avec les autres. La mesure d'interaction concerne la part de la variance de F(X) s’explique par l’interaction. La mesure est comprise entre 0 (pas d'interaction) et 1 (= 100 % de variance deF(X) en raison des interactions). Pour chaque fonctionnalité, nous mesurons dans quelle mesure elles interagissent avec toute autre fonctionnalité.
interact <- Interaction$new(predictor)
plot(interact)
# cat("Predictor interactions: Land use")
# interact <- Interaction$new(predictor, feature = "LC_")
# plot(interact)

```
:::


## Richness

::: {.panel-tabset}

## Predictors importances


```{r Richesse_tot importance,fig.align='center', eval=TRUE}
# best_vars_Richesse_tot_RF
Richesse_tot_df = landworm_explo_non_t[,c("Richesse_tot",best_vars_Richesse_tot_RF)]
# names(Richesse_tot_df)
Richesse_tot_df = drop_na(Richesse_tot_df)


rf <- randomForest(Richesse_tot ~ ., data = Richesse_tot_df)
# rf <- glm(Richesse_tot ~ ., data = Richesse_tot_df, family = 'gaussian')

# Utilisation du conteneur iml Predictor()
X <- Richesse_tot_df[which(names(Richesse_tot_df) != "Richesse_tot")]
predictor <- Predictor$new(rf, data = X, y = Richesse_tot_df$Richesse_tot)

set.seed(0012)
imp_Richesse_tot <- FeatureImp$new(predictor, loss = "rmse") 
# imp_Richesse_tot <- FeatureImp$new(predictor, loss = "mse") # mean squared error
plot(imp_Richesse_tot)

# Importance des fonctionnalités
# On calcule l'importance de chaque caractéristique pour les prédictions avec FeatureImp. La mesure de l'importance des fonctionnalités fonctionne en mélangeant chaque fonctionnalité et en mesurant l'ampleur de la baisse des performances. Pour cette tâche de régression, nous choisissons de mesurer la perte de performance avec l'erreur absolue moyenne (« mae »), un autre choix serait l'erreur quadratique moyenne (« mse »).

# https://christophm.github.io/interpretable-ml-book/feature-importance.html

```


## Predictors effects


```{r Richesse_tot effets, eval=TRUE}
# Effets de fonctionnalités
# Les effets locaux accumulés décrivent comment les predicteurs influencent en moyenne la prédiction d'un modèle d'apprentissage automatique: ALE montre comment la prédiction change localement, lorsque les predicteurs varie. Les marques sur l'axe des x indiquent la distribution des predicteurs, montrant la pertinence d'une région pour l'interprétation (peu ou pas de points signifie que nous ne devons pas surinterpréter cette région).

# ale <- FeatureEffect$new(predictor, feature = "gps_x") # uniquement lstat
# ale$plot()
# ale$set.feature("rm")
# ale$plot()
effs <- FeatureEffects$new(predictor) # toutes les variables
plot(effs)

```


## Predictors interactions


```{r Richesse_tot interaction , eval=TRUE}

# Mesurer les interactions
# Nous pouvons également mesurer la force avec laquelle les fonctionnalités interagissent les unes avec les autres. La mesure d'interaction concerne la part de la variance de F(X) s’explique par l’interaction. La mesure est comprise entre 0 (pas d'interaction) et 1 (= 100 % de variance deF(X) en raison des interactions). Pour chaque fonctionnalité, nous mesurons dans quelle mesure elles interagissent avec toute autre fonctionnalité.
interact <- Interaction$new(predictor)
plot(interact)
# cat("Predictor interactions: Land use")
# interact <- Interaction$new(predictor, feature = "LC_")
# plot(interact)

```

:::

# Prediction and mapping

```{r, warning=FALSE,message=FALSE}

france_shapefile <- st_read("cartographie/france_shapefile_sans_corse.shp")

Predictors_f = unique(c(best_vars_AB_tot_RF, 
                        best_vars_BM_tot_RF,
                        best_vars_Richesse_tot_RF))

# dput(Predictors_f)

Predictors_f = c("LC_", "CN", "pr_mean_6", "pet_mean_3", "K", "tasmin_sd_6", 
                "tasmin_mean_120", "tasmin_mean_6", "Clay", "pr_sd_120", 
                "tas_mean_120", "CaCO3", "tas_sd_120", "pH", "pr_mean_120", 
                "Sand", "pet_sd_120", "tasmax_sd_3", "tasmin_sd_120", "pr_sd_3", 
                "Silt", "P", "tas_sd_6", "tasmax_sd_120")

Predictors_f_sol = c("CN", "K", "Clay", "CaCO3", "pH", "Sand", "Silt", "P")

Predictors_f_climat = c("pr_mean_6", "pet_mean_3", "tasmin_sd_6", "tasmin_mean_120", 
                        "tasmin_mean_6", "pr_sd_120", "tas_mean_120", "tas_sd_120",
                        "pr_mean_120", "pet_sd_120", "tasmax_sd_3", "tasmin_sd_120", 
                        "pr_sd_3", "tas_sd_6", "tasmax_sd_120")


# dput(Predictors_f[!Predictors_f %in% Predictors_f_sol])

```






## Extraction

**Datas preparations**


-   **Land use**

-   **Soils predictors**

-   **Climate predictors**




```{r}
predictors <- readRDS("cartographie/predictors.rds")
# summary(predictors)
# str(predictors)

predictors = predictors[,c("gps_x", "gps_y","clcm_lvl3")]

prdtors_LC_soil = readRDS("cartographie/prdtors_LC_soil.rds")

```




## Import best models and predictions

**Abundance**
```{r Abundance prediction, echo=TRUE}
# mod_AB_tot = readRDS("cartographie/best_mod/RF_mod_AB_tot.RDS")
# 
# AB_tot_pred<- predict(mod_AB_tot, newdata = predictors_trans)
# AB_tot_pred = round(as.numeric(AB_tot_pred))
# # summary(AB_tot_pred)
# AB_tot_pred = data.frame(Abundance = AB_tot_pred, Longitude = predictors$gps_x, Latitude = predictors$gps_y)
# 
# write.csv(x =AB_tot_pred,file = "cartographie/AB_tot_pred.csv",row.names = FALSE)
# 
# saveRDS(AB_tot_pred, "cartographie/AB_tot_pred.rds")
# 
# AB_tot_pred = readRDS("cartographie/AB_tot_pred.rds")


```

**Biomass**
```{r Biomass prediction, echo=TRUE}
# mod_BM_tot = readRDS("cartographie/best_mod/RF_mod_BM_tot.RDS")
# 
# BM_tot_pred<- predict(mod_BM_tot, newdata = predictors_trans)
# BM_tot_pred = round(as.numeric(BM_tot_pred))
# # summary(BM_tot_pred)
# BM_tot_pred = data.frame(Biomass = BM_tot_pred, Longitude = predictors$gps_x, Latitude = predictors$gps_y)
# 
# write.csv(x =BM_tot_pred,file = "cartographie/BM_tot_pred.csv",row.names = FALSE)
# 
# saveRDS(BM_tot_pred, "cartographie/BM_tot_pred.rds")

# BM_tot_pred = readRDS("cartographie/BM_tot_pred.rds")
```

**Richness**
```{r Richness prediction, echo=TRUE}
# mod_Richesse_tot = readRDS("cartographie/best_mod/RF_mod_Richesse_tot.RDS")
# 
# Richesse_tot_pred<- predict(mod_Richesse_tot, newdata = predictors_trans)
# Richesse_tot_pred = round(as.numeric(Richesse_tot_pred))
# # summary(Richesse_tot_pred)
# Richesse_tot_pred = data.frame(Richness = Richesse_tot_pred, Longitude = predictors$gps_x, Latitude = predictors$gps_y)
# 
# write.csv(x =Richesse_tot_pred,file = "cartographie/Richesse_tot_pred.csv",row.names = FALSE)
# 
# saveRDS(Richesse_tot_pred, "cartographie/Richesse_tot_pred.rds")
# 
# Richesse_tot_pred = readRDS("cartographie/Richesse_tot_pred.rds")

```

## Interpolation


**Sampling**

- 800 m regular grid

- Stores gps coordinates

```{r Cartographie}
#grille régulière couvrant la zone géographique d'intérêt
res <- 0.008333333  # Résolution de la grille en degrés
grid <- expand.grid(x = seq(from = -5.141277, to = 8.232497, by = res),
                    y = seq(from = 42.33292, to = 51.08899, by = res))

df_point_gps_ech = as.data.frame(grid)

# point_gps_ech = ggplot() +
#   geom_point(aes(x = x, y = y), data = df_point_gps_ech) +
#   geom_sf(fill = 'transparent', data = france_shapefile)
# 
# ggsave("cartographie/point_gps_ech.png", plot = point_gps_ech, dpi = 300
#        ,height = 2.8,width = 5)

coordinates(grid) <- ~x + y
gridded(grid) <- TRUE

```


<p align="center">
  <img src="cartographie/point_gps_ech.png">
</p>





**Fig. Interpolation**

<p align="center">
  <img src="interpolation.png">
</p>

```{r}
couleur <- colorRampPalette(c("red", "darkorange", "orange", "goldenrod1", "yellow", "yellow", "yellow","greenyellow", "greenyellow", "greenyellow", "greenyellow", "greenyellow", "greenyellow", "green", "green", "green2", "green2", "green2", "green2", "green2", "green2", "green3", "green4", "green4"))(255)

```


## Abundance


```{r Abundance map}
# AB_tot_pred = readRDS("cartographie/AB_tot_pred.rds")
# df <- AB_tot_pred
# df$Abundance = df$Abundance^2

# #1
# AB_tot_mesuree = landworm_explo_non_t[, c("AB_tot","gps_x", "gps_y")]
# colnames(AB_tot_mesuree) = c("Abundance","Longitude","Latitude")
# AB_tot_mesuree$Abundance = round(AB_tot_mesuree$Abundance)
# AB_tot_mesuree = AB_tot_mesuree[!AB_tot_mesuree$Abundance>800,]
# # AB_tot_mesuree$Longitude = round(AB_tot_mesuree$Longitude, 6)
# # AB_tot_mesuree$Latitude = round(AB_tot_mesuree$Latitude, 5)
# 
# 
# df = rbind(df,AB_tot_mesuree)
###
# temps1 = Sys.time()
# # Convertir le dataframe en SpatialPointsDataFrame
# coordinates(df) <- c("Longitude", "Latitude")
# 
# pts_a_idw_gps = pts_a_idw[,c("Longitude", "Latitude")]
# colnames(pts_a_idw_gps) <- c("x", "y")
# coordinates(pts_a_idw_gps) <- ~x + y
# gridded(pts_a_idw_gps) <- TRUE

#grille régulière couvrant la zone géographique d'intérêt
# res <- 0.008333333  # Résolution de la grille en degrés
# grid <- expand.grid(x = seq(from = -5.141277, to = 8.232497, by = res),
#                     y = seq(from = 42.33292, to = 51.08899, by = res))
# coordinates(grid) <- ~x + y
# gridded(grid) <- TRUE
# 

# Interpolation des valeurs de AB_tot des vers de terre sur la grille
# idw_AB_tot <- gstat::idw(Abundance ~ 1, df, newdata = pts_a_idw_gps,nmax=10, idp =10)
# saveRDS(idw_AB_tot, "cartographie/idw_AB_tot.rds")
# idw_AB_tot = readRDS("cartographie/idw_AB_tot.rds")
# Abundance_raster <- raster(idw_AB_tot)
# 
# # crs(Abundance_raster) = "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
# crs(Abundance_raster) = crs(france_shapefile)
# res(Abundance_raster) = 0.008333333
# extent(Abundance_raster) = extent(france_shapefile)
# Abundance_raster = raster::mask(Abundance_raster,france_shapefile)
# 
# raster::writeRaster(x = Abundance_raster,filename = "cartographie/raster_AB_tot.tif", overwrite=TRUE)
# 
# temps2 = Sys.time()
# duree = difftime(temps2,temps1)
# duree

###


# Abundance_raster <- raster("cartographie/raster_AB_tot.tif")

# plot(Abundance_raster, main = "Abundance ")
# mapview::mapview(Abundance_raster, main = "Abundance", maxpixels  = 2001670)



# # Manipulating data
# 
# 
# #1
# AB_tot_mesuree = landworm_explo_non_t[, c("gps_x", "gps_y", "AB_tot")]
# colnames(AB_tot_mesuree) = c("Longitude","Latitude","Abundance")
# AB_tot_mesuree$Abundance = round(AB_tot_mesuree$Abundance)
# AB_tot_mesuree$Longitude = round(AB_tot_mesuree$Longitude, 6)
# AB_tot_mesuree$Latitude = round(AB_tot_mesuree$Latitude, 5)
# 
# 
# #2
# df <- AB_tot_pred
# df$Abundance = df$Abundance^2
# 
# 
# df_AB_tot_all = rbind(AB_tot_mesuree,df)
# write.csv(x =df_AB_tot_all,file = "cartographie/df_AB_tot_all.csv",row.names = FALSE)
#
```


```{r Abundance map2, fig.dpi=300, eval=FALSE}
# df <- AB_tot_pred
# df$Abundance = df$Abundance^2
# 
# Abundance_raster <- raster("cartographie/raster_AB_tot.tif")
# x <- rasterize(df[, 2:3], Abundance_raster, df[,1], fun=mean)
# raster::writeRaster(x = x,filename = "cartographie/x.tif", overwrite=TRUE)
# # plot(x)
# rasdf_x <- as.data.frame(x,xy=TRUE) #%>%drop_na()
# colnames(rasdf_x) = c("Longitude", "Latitude","Abundance")
# pts_a_idw = rasdf_x[is.na(rasdf_x$Abundance), ]
# # rasdf_x$ID = paste0(rasdf_x$Longitude,"_",rasdf_x$Latitude)
# clean_rasdf_x = drop_na(rasdf_x)
# 
# df <- AB_tot_pred
# df$Abundance = df$Abundance^2
# coordinates(df) <- c("Longitude", "Latitude")
# pts_a_idw_gps = pts_a_idw[,c("Longitude", "Latitude")]
# colnames(pts_a_idw_gps) <- c("x", "y")
# coordinates(pts_a_idw_gps) <- ~x + y
# idw_AB_tot <- gstat::idw(Abundance ~ 1, df, newdata = pts_a_idw_gps,nmax=10, idp =10)
# saveRDS(idw_AB_tot, "cartographie/idw_AB_tot.rds")
# 
# idw_rasdf_x = data.frame(Longitude = pts_a_idw$Longitude,
#                           Latitude = pts_a_idw$Latitude ,
#                           Abundance = idw_AB_tot$var1.pred)
# all_pts_AB_tot = rbind(clean_rasdf_x, idw_rasdf_x)
# saveRDS(all_pts_AB_tot, "cartographie/all_pts_AB_tot.rds")
# 
# all_pts_AB_tot = readRDS("cartographie/all_pts_AB_tot.rds")
# 
# r_all_pts_AB_tot = raster::rasterize(all_pts_AB_tot[, 1:2], Abundance_raster, all_pts_AB_tot[,3], fun=mean)
# r_all_pts_AB_tot = raster::mask(r_all_pts_AB_tot,france_shapefile)
# raster::writeRaster(x = r_all_pts_AB_tot,filename = "cartographie/r_all_pts_AB_tot.tif", overwrite=TRUE)
# r_all_pts_AB_tot = raster("cartographie/r_all_pts_AB_tot.tif")


# raster::plot(r_all_pts_AB_tot, main = "Predicted total \nabundance (ind./m²)",
#      col=couleur ,add=FALSE, axes = FALSE, box=FALSE)
# plot(france_shapefile,add=TRUE, color="gray", alpha=0.001, axes = FALSE)

# Abundance = r_all_pts_AB_tot
# mapview::mapview(Abundance, col.regions = couleur, legend = TRUE, main = "Abundance", maxpixels =  '1686855', legend.name = "Predicted total \nabundance (ind./m²)")

# 
# df_AB_tot_carte = rasdf
# df_AB_tot_carte[df_AB_tot_carte$Abundance>700, "Abundance"]=700
# Plotting

# df_AB_tot_pred = as.data.frame(r_all_pts_AB_tot,xy=TRUE)
# colnames(df_AB_tot_pred) <- c("x", "y","Abundance")
# carte_AB_tot =  ggplot() +
#   geom_raster(aes(x = x, y = y, fill = Abundance), data = df_AB_tot_pred) +
#   geom_sf(fill = 'transparent', data = france_shapefile) +
#   scale_fill_gradientn(
#     colors = couleur,
#     name = 'Predicted total \nabundance (ind./m²)\n',
#     breaks = c(100, 200, 300, 400, 500),
#     labels = c('100', '200', '300', '400', '500'),
#     na.value = "white"
#   )+
#   labs(x='Longitude',y='Latitude',
#        # title="Total Abundance map",
#        # subtitle='',
#        # caption='Source: LandWorm, 2024'
#        )+
#   theme(panel.grid.major = element_line(color = gray(.5),
#                                         linetype = 'dashed',
#                                         size = 0.1),
#         panel.grid.minor = element_blank(),
#         panel.background = element_rect(fill=NA,color = 'black'),
#         panel.ontop = TRUE,
#         axis.text = element_text(size = 8),
#         axis.title.y = element_text(vjust = 5, size = 10, face = "bold"),
#         axis.title.x = element_text(size = 10, face = "bold",vjust = -1),
#         axis.ticks.length = unit(0.2, "cm"),
#         plot.caption = element_text(vjust = -1.5),
#         plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm")) #gauche,droite,haut,bas
# 
# carte_AB_tot
# ggsave("cartographie/carte_AB_tot.png", plot = carte_AB_tot, dpi = 300
#        ,height = 2.8,width = 5
#        )


```

<p align="center">
  <img src="cartographie/carte_AB_tot.png">
</p>


## Biomass




```{r Biomass map , eval=FALSE}
# BM_tot_pred = readRDS("cartographie/BM_tot_pred.rds")
# df <- BM_tot_pred
# df$Biomass = df$Biomass^2

# #1
# BM_tot_mesuree = landworm_explo_non_t[, c("BM_tot","gps_x", "gps_y")]
# colnames(BM_tot_mesuree) = c("Biomass","Longitude","Latitude")
# # BM_tot_mesuree$Biomass = round(BM_tot_mesuree$Biomass)
# # BM_tot_mesuree$Longitude = round(BM_tot_mesuree$Longitude, 6)
# # BM_tot_mesuree$Latitude = round(BM_tot_mesuree$Latitude, 5)
# 
# 
# df = rbind(df,BM_tot_mesuree)
# df = drop_na(df)
###
# temps1 = Sys.time()
# # Convertir le dataframe en SpatialPointsDataFrame
# coordinates(df) <- c("Longitude", "Latitude")
# 
# #grille régulière couvrant la zone géographique d'intérêt
# res <- 0.008333333  # Résolution de la grille en degrés
# grid <- expand.grid(x = seq(from = -5.141277, to = 8.232497, by = res),
#                     y = seq(from = 42.33292, to = 51.08899, by = res))
# coordinates(grid) <- ~x + y
# gridded(grid) <- TRUE
# 
# 
# # Interpolation des valeurs de BM_tot des vers de terre sur la grille
# idw_BM_tot <- gstat::idw(Biomass ~ 1, df, newdata = grid,nmax=5, idp =10)
# saveRDS(idw_BM_tot, "cartographie/idw_BM_tot.rds")
# # idw_BM_tot = readRDS("cartographie/idw_BM_tot.rds")
# Biomass_raster <- raster(idw_BM_tot)
# 
# temps2 = Sys.time()
# duree = difftime(temps2,temps1)
# duree
# 
# 
# 
# # crs(Biomass_raster) = "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
# crs(Biomass_raster) = crs(france_shapefile)
# res(Biomass_raster) = 0.008333333
# extent(Biomass_raster) = extent(france_shapefile)
# Biomass_raster = raster::mask(Biomass_raster,france_shapefile)
# 
# raster::writeRaster(x = Biomass_raster,filename = "cartographie/raster_BM_tot.tif", overwrite=TRUE)

###


# Biomass_raster <- raster("cartographie/raster_BM_tot.tif")

# plot(Biomass_raster, main = "Biomass ")
# mapview::mapview(Biomass_raster, main = "Biomass", maxpixels  = 2001670)



# # Manipulating data
# rasdf <- as.data.frame(Biomass_raster,xy=TRUE)%>%drop_na()
# # head(rasdf)
# colnames(rasdf) = c("x","y","Biomass")
# df_BM_tot_carte = rasdf
# df_BM_tot_carte[df_BM_tot_carte$Abundance>300, "Biomass"]=300


# df <- BM_tot_pred
# df$Biomass = df$Biomass^2
# 
# Biomass_raster <- raster("cartographie/raster_BM_tot.tif")
# x <- rasterize(df[, 2:3], Biomass_raster, df[,1], fun=mean)
# raster::writeRaster(x = x,filename = "cartographie/x_BM_tot.tif", overwrite=TRUE)
# # plot(x)
# rasdf_x <- as.data.frame(x,xy=TRUE) #%>%drop_na()
# colnames(rasdf_x) = c("Longitude", "Latitude","Biomass")
# pts_a_idw = rasdf_x[is.na(rasdf_x$Biomass), ]
# # rasdf_x$ID = paste0(rasdf_x$Longitude,"_",rasdf_x$Latitude)
# clean_rasdf_x = drop_na(rasdf_x)
# 
# df <- BM_tot_pred
# df$Biomass = df$Biomass^2
# coordinates(df) <- c("Longitude", "Latitude")
# pts_a_idw_gps = pts_a_idw[,c("Longitude", "Latitude")]
# colnames(pts_a_idw_gps) <- c("x", "y")
# coordinates(pts_a_idw_gps) <- ~x + y
# idw_BM_tot <- gstat::idw(Biomass ~ 1, df, newdata = pts_a_idw_gps,nmax=5, idp =10)
# saveRDS(idw_BM_tot, "cartographie/idw_BM_tot.rds")
# 
# idw_rasdf_x = data.frame(Longitude = pts_a_idw$Longitude,
#                           Latitude = pts_a_idw$Latitude ,
#                           Biomass = idw_BM_tot$var1.pred)
# all_pts_BM_tot = rbind(clean_rasdf_x, idw_rasdf_x)
# saveRDS(all_pts_BM_tot, "cartographie/all_pts_BM_tot.rds")
# 
# all_pts_BM_tot = readRDS("cartographie/all_pts_BM_tot.rds")
# 
# r_all_pts_BM_tot = rasterize(all_pts_BM_tot[, 1:2], x, all_pts_BM_tot[,3], fun=mean)
# r_all_pts_BM_tot = raster::mask(r_all_pts_BM_tot,france_shapefile)
# raster::writeRaster(x = r_all_pts_BM_tot,filename = "cartographie/r_all_pts_BM_tot.tif", overwrite=TRUE)
# r_all_pts_BM_tot = raster("cartographie/r_all_pts_BM_tot.tif")
# xlim <- c(-5.141277, 8.232497)
# ylim <- c(42.33292, 51.08899)
# plot(r_all_pts_BM_tot, main = "Predicted total \nbiomass (ind./g)",
#           col=colorRampPalette(c("red", "darkorange", "orange", "goldenrod1", "yellow", "yellow", "yellow","greenyellow", "greenyellow", "greenyellow", "greenyellow", "greenyellow", "greenyellow", "green", "green", "green2", "green2", "green2", "green2", "green2", "green2", "green3", "green4", "green4"))(255) , xlim = xlim, ylim = ylim)
# plot(france_shapefile,add=TRUE, color="gray", alpha=0.001)


# df_BM_tot_pred = as.data.frame(r_all_pts_BM_tot,xy=TRUE)
# colnames(df_BM_tot_pred) <- c("x", "y","Biomass")
# carte_BM_tot =  ggplot() +
#   geom_raster(aes(x = x, y = y, fill = Biomass), data = df_BM_tot_pred) +
#   geom_sf(fill = 'transparent', data = france_shapefile) +
#   scale_fill_gradientn(
#     colors = couleur,
#     name = 'Predicted total \nbiomass (g/m²)\n',
#     breaks = c(50, 100, 150, 200),
#     labels = c('50', '100', '150', '200'),
#     na.value = "white"
#   )+
#   labs(x='Longitude',y='Latitude',
#        # title="Total Biomass map",
#        # subtitle='',
#        # caption='Source: LandWorm, 2024'
#        )+
#   theme(panel.grid.major = element_line(color = gray(.5),
#                                         linetype = 'dashed',
#                                         size = 0.1),
#         panel.grid.minor = element_blank(),
#         panel.background = element_rect(fill=NA,color = 'black'),
#         panel.ontop = TRUE,
#         axis.text = element_text(size = 8),
#         axis.title.y = element_text(vjust = 5, size = 10, face = "bold"),
#         axis.title.x = element_text(size = 10, face = "bold",vjust = -1),
#         axis.ticks.length = unit(0.2, "cm"),
#         plot.caption = element_text(vjust = -1.5),
#         plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm")) #gauche,droite,haut,bas
# 
# carte_BM_tot
# ggsave("cartographie/carte_BM_tot.png", plot = carte_BM_tot, dpi = 300
#        ,height = 2.8,width = 5
#        )
```

<p align="center">
  <img src="cartographie/carte_BM_tot.png">
</p>


## Richness




```{r Richness map , eval=FALSE}
# Richesse_tot_pred = readRDS("cartographie/Richesse_tot_pred.rds")
# df <- Richesse_tot_pred
# 

# #1
# Richesse_tot_mesuree = landworm_explo_non_t[, c("Richesse_tot","gps_x", "gps_y")]
# colnames(Richesse_tot_mesuree) = c("Richness","Longitude","Latitude")
# Richesse_tot_mesuree$Richness = round(Richesse_tot_mesuree$Richness)
# # Richesse_tot_mesuree$Longitude = round(Richesse_tot_mesuree$Longitude, 6)
# # Richesse_tot_mesuree$Latitude = round(Richesse_tot_mesuree$Latitude, 5)
# 
# 
# df = rbind(df,Richesse_tot_mesuree)
# ###
# temps1 = Sys.time()
# # Convertir le dataframe en SpatialPointsDataFrame
# coordinates(df) <- c("Longitude", "Latitude")
# 
# #grille régulière couvrant la zone géographique d'intérêt
# res <- 0.008333333  # Résolution de la grille en degrés
# grid <- expand.grid(x = seq(from = -5.141277, to = 8.232497, by = res),
#                     y = seq(from = 42.33292, to = 51.08899, by = res))
# coordinates(grid) <- ~x + y
# gridded(grid) <- TRUE
# 
# 
# # Interpolation des valeurs de Richesse_tot des vers de terre sur la grille
# idw_Richesse_tot <- gstat::idw(Richness ~ 1, df, newdata = grid,nmax=10, idp =10)
# saveRDS(idw_Richesse_tot, "cartographie/idw_Richesse_tot.rds")
# # idw_Richesse_tot = readRDS("cartographie/idw_Richesse_tot.rds")
# Richness_raster <- raster(idw_Richesse_tot)
# 
# temps2 = Sys.time()
# duree = difftime(temps2,temps1)
# duree
# 
# 
# 
# # crs(Richness_raster) = "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
# crs(Richness_raster) = crs(france_shapefile)
# res(Richness_raster) = 0.008333333
# extent(Richness_raster) = extent(france_shapefile)
# Richness_raster = raster::mask(Richness_raster,france_shapefile)
# 
# raster::writeRaster(x = Richness_raster,filename = "cartographie/raster_Richesse_tot.tif", overwrite=TRUE)

###


# Richness_raster <- raster("cartographie/raster_Richesse_tot.tif")

# plot(Richness_raster, main = "Richness ")
# mapview::mapview(Richness_raster, main = "Richness", maxpixels  = 2001670)
# 
# 
# 
# # Manipulating data
# rasdf <- as.data.frame(Richness_raster,xy=TRUE)%>%drop_na()
# # head(rasdf)
# colnames(rasdf) = c("x","y","Richness")
# 
# df_Richesse_tot_carte = rasdf

# df <- Richesse_tot_pred
# Richness_raster <- raster("cartographie/raster_Richesse_tot.tif")
# x <- rasterize(df[, 2:3], Richness_raster, df[,1], fun=mean)
# raster::writeRaster(x = x,filename = "cartographie/x.tif", overwrite=TRUE)
# # plot(x)
# rasdf_x <- as.data.frame(x,xy=TRUE) #%>%drop_na()
# colnames(rasdf_x) = c("Longitude", "Latitude","Richness")
# pts_a_idw = rasdf_x[is.na(rasdf_x$Richness), ]
# # rasdf_x$ID = paste0(rasdf_x$Longitude,"_",rasdf_x$Latitude)
# clean_rasdf_x = drop_na(rasdf_x)
# 
# df <- Richesse_tot_pred
# coordinates(df) <- c("Longitude", "Latitude")
# pts_a_idw_gps = pts_a_idw[,c("Longitude", "Latitude")]
# colnames(pts_a_idw_gps) <- c("x", "y")
# coordinates(pts_a_idw_gps) <- ~x + y
# idw_Richesse_tot <- gstat::idw(Richness ~ 1, df, newdata = pts_a_idw_gps,nmax=5, idp =10)
# saveRDS(idw_Richesse_tot, "cartographie/idw_Richesse_tot.rds")
# 
# idw_rasdf_x = data.frame(Longitude = pts_a_idw$Longitude,
#                           Latitude = pts_a_idw$Latitude ,
#                           Richness = round(idw_Richesse_tot$var1.pred))
# all_pts_Richesse_tot = rbind(clean_rasdf_x, idw_rasdf_x)
# saveRDS(all_pts_Richesse_tot, "cartographie/all_pts_Richesse_tot.rds")
# 
# all_pts_Richesse_tot = readRDS("cartographie/all_pts_Richesse_tot.rds")
# 
# r_all_pts_Richesse_tot = rasterize(all_pts_Richesse_tot[, 1:2], x, all_pts_Richesse_tot[,3], fun=mean)
# r_all_pts_Richesse_tot = raster::mask(r_all_pts_Richesse_tot,france_shapefile)
# raster::writeRaster(x = r_all_pts_Richesse_tot,filename = "cartographie/r_all_pts_Richesse_tot.tif", overwrite=TRUE)
# r_all_pts_Richesse_tot = raster("cartographie/r_all_pts_Richesse_tot.tif")
# xlim <- c(-5.141277, 8.232497)
# ylim <- c(42.33292, 51.08899)
# plot(r_all_pts_Richesse_tot, main = "Predicted total \nrichness (nr. of spp.)",
#                col=colorRampPalette(c("red", "darkorange", "orange", "goldenrod1", "yellow", "yellow", "yellow","greenyellow", "greenyellow", "greenyellow", "greenyellow", "greenyellow", "greenyellow", "green", "green", "green2", "green2", "green2", "green2", "green2", "green2", "green3", "green4", "green4"))(255) , xlim = xlim, ylim = ylim)
# plot(france_shapefile,add=TRUE, color="gray", alpha=0.001)
# 



# df_Richesse_tot_pred = as.data.frame(r_all_pts_Richesse_tot,xy=TRUE)
# colnames(df_Richesse_tot_pred) <- c("x", "y","Richness")
# carte_Richesse_tot =  ggplot() +
#   geom_raster(aes(x = x, y = y, fill = Richness), data = df_Richesse_tot_pred) +
#   geom_sf(fill = 'transparent', data = france_shapefile) +
#   scale_fill_gradientn(
#     colors = couleur,
#     name = 'Predicted total \nrichness (nr. of spp.)\n',
#     breaks = c(2, 4, 6, 8, 10),
#     labels = c('2', '4', '6', '8', '10'),
#     na.value = "white"
#   )+
#   labs(x='Longitude',y='Latitude',
#        )+
#   theme(panel.grid.major = element_line(color = gray(.5),
#                                         linetype = 'dashed',
#                                         size = 0.1),
#         panel.grid.minor = element_blank(),
#         panel.background = element_rect(fill=NA,color = 'black'),
#         panel.ontop = TRUE,
#         axis.text = element_text(size = 8),
#         axis.title.y = element_text(vjust = 5, size = 10, face = "bold"),
#         axis.title.x = element_text(size = 10, face = "bold",vjust = -1),
#         axis.ticks.length = unit(0.2, "cm"),
#         plot.caption = element_text(vjust = -1.5),
#         plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm")) #gauche,droite,haut,bas
# 
# carte_Richesse_tot
# ggsave("cartographie/carte_Richesse_tot.png", plot = carte_Richesse_tot, dpi = 300
#        ,height = 2.8,width = 5
#        )

```


<p align="center">
  <img src="cartographie/carte_Richesse_tot.png">
</p>


## Approximate earthworm diversity

```{r, eval=FALSE}
# df1=df_AB_tot_pred # Abundance
# df2=df_Richesse_tot_pred # Richesse_tot
# colnames(df1) = colnames(df2)=c("x","y","values")
# 
# # Fonction de normalisation min-max
# normalize <- function(x) {
#   return((x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)))
# }
# 
# 
# df1_normalized <- df1 %>%
#   mutate(values_normalized = normalize(values))
# 
# df2_normalized <- df2 %>%
#   mutate(values_normalized = normalize(values))
# 
# 
# df_merged <- full_join(df1_normalized, df2_normalized, by = c("x", "y"))
# df_merged$biodiversity = df_merged$values_normalized.x + df_merged$values_normalized.y
# 
# biodiversity =  ggplot() +
#   geom_raster(aes(x = x, y = y, fill = biodiversity), data = df_merged) +
#   # geom_raster(aes(x = x, y = y, fill = values), data = df2) +
#   geom_sf(fill = 'transparent', data = france_shapefile) +
#   scale_fill_gradientn(
#     colors = couleur,
#     name = 'Predicted approximate \nearthworm diversity\n',
#     breaks = c(0.2, 0.6, 1, 1.4, 1.8),
#     labels = c("Very low","Low","Medium","High","Very high"),
#     na.value = "white"
#   )+
#   labs(x='Longitude',y='Latitude',
#        # title="Total Abundance map",
#        # subtitle='',
#        # caption='Source: LandWorm, 2024'
#        )+
#   theme(panel.grid.major = element_line(color = gray(.5),
#                                         linetype = 'dashed',
#                                         size = 0.1),
#         panel.grid.minor = element_blank(),
#         panel.background = element_rect(fill=NA,color = 'black'),
#         panel.ontop = TRUE,
#         axis.text = element_text(size = 8),
#         axis.title.y = element_text(vjust = 5, size = 10, face = "bold"),
#         axis.title.x = element_text(size = 10, face = "bold",vjust = -1),
#         axis.ticks.length = unit(0.2, "cm"),
#         plot.caption = element_text(vjust = -1.5),
#         plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm")) #gauche,droite,haut,bas
# 
# biodiversity
# 
# ggsave("cartographie/biodiversity.png", plot = biodiversity, dpi = 300
#        ,height = 2.8,width = 5
#        )

```

<p align="center">
  <img src="cartographie/biodiversity.png">
</p>





## Mapview

```{r app mapview, eval=FALSE}
# # Abundance
# Abundance = r_all_pts_AB_tot
# val_ab = values(Abundance)
# val_ab <- ifelse(!is.na(val_ab), round(val_ab), NA)
# values(Abundance) = val_ab
# 
# # Biomass
# Biomass = round(r_all_pts_BM_tot)
# 
# # Richness
# Richness = round(r_all_pts_Richesse_tot)
# 
# map = mapview::mapview(Abundance, col.regions = couleur, legend = TRUE, layer.name = "Abundance (ind.m-²)", main = "Abundance", maxpixels = '1686855', trim=FALSE) +
# 
#  mapview::mapview(Biomass, col.regions = couleur, legend = TRUE, layer.name = "Biomass (ind.g)")+
# 
# mapview::mapview(Richness, col.regions = couleur, legend = TRUE, layer.name = "Richness (nr. of spp.)", trim=FALSE, maxpixels =  "2001670")
# 
# map

# carte_AB_tot
# carte_BM_tot
# carte_Richesse_tot
# biodiversity

form <- function(g) {
  gg <- g +
    labs(x = '', y = '') +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.background = element_blank(),
      panel.ontop = TRUE,
      axis.text = element_blank(),
      axis.title.y = element_blank(),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(0, "cm"),
    legend.key.size = unit(1, 'cm'), #change legend key size
    legend.key.height = unit(0.4, 'cm'), #change legend key height
    legend.key.width = unit(0.4, 'cm'), #change legend key width
    legend.title = element_text(size=7), #change legend title font size
    legend.text = element_text(size=6) #change legend text font size
    )
  return(gg)
}
# 
# 
# g_carte_AB_tot = form(carte_AB_tot)
# g_carte_BM_tot = form(carte_BM_tot)
# g_carte_Richesse_tot = form(carte_Richesse_tot)
# g_biodiversity = form(biodiversity)
# 
# carte_vdt = ggarrange(g_carte_AB_tot, g_carte_BM_tot, g_carte_Richesse_tot, g_biodiversity,
#   labels = c('(a)', '(b)','(c)', '(d)'),align = "hv" , ncol = 2, nrow=2
#   # ,widths = 10,
#   # common.legend = TRUE,
#   # legend = 'right'
# )
# carte_vdt
# ggsave("cartographie/carte_vdt.png", plot = carte_vdt, dpi = 300
#        ,height = 4.5,width = 6.5
#        )


# ggsave("cartographie/g_carte_AB_tot.png", plot = g_carte_AB_tot, dpi = 300
#        ,height = 3.5,width = 5.5
#        )
# 
# ggsave("cartographie/g_carte_BM_tot.png", plot = g_carte_BM_tot, dpi = 300
#        ,height = 3.5,width = 5.5
#        )
# 
# ggsave("cartographie/g_carte_Richesse_tot.png", plot = g_carte_Richesse_tot, dpi = 300
#        ,height = 3.5,width = 5.5
#        )
# 
# ggsave("cartographie/g_biodiversity.png", plot = g_biodiversity, dpi = 300
#        ,height = 3.5,width = 5.5
#        )


```

<p align="center">
  <img src="cartographie/carte_vdt.png">
</p>


See [Mapping earthworm prediction in France](https://rpubs.com/Abdou_diallo/1184840){target="_blank"}



## Co-kriging

```{r, eval= FALSE}

library(gstat)
library(sp)

# Exemple de données
set.seed(123)
df <- data.frame(
  x = runif(20, 0, 10),
  y = runif(20, 0, 10),
  abundance = rnorm(20, 5, 2),
  land_use = factor(sample(1:6, 20, replace = TRUE))
)
coordinates(df) <- ~x + y

# Création de variables indicatrices pour l'occupation du sol
df_ind <- model.matrix(~ land_use - 1, data = df)
df_ind <- as.data.frame(df_ind)
df <- cbind(df, df_ind)

# Grille pour l'interpolation
grd <- expand.grid(x = seq(0, 10, by = 0.5), y = seq(0, 10, by = 0.5))
coordinates(grd) <- ~x + y

# Définition des modèles gstat pour co-kriging
g <- gstat(NULL, id = "abundance", form = abundance ~ 1, data = df)
for(i in colnames(df_ind)) {
  g <- gstat(g, id = i, form = as.formula(paste(i, "~ 1")), data = df)
  g <- gstat(g, id = "abundance", form = as.formula(paste("abundance ~", i)), data = df)
}

# Calcul des variogrammes expérimentaux
v <- variogram(g)

# Ajustement des modèles de variogramme théorique
vgm <- fit.lmc(v, g, model = vgm(1, "Sph", 1, 1))

# Prédire les valeurs
ck_result <- predict(vgm, grd)

# Visualiser les résultats
spplot(ck_result["var1.pred"], main = "Predicted Abundance")

```


# Writing 




## Cate M&M
```{r, eval=FALSE}
# 
# fr_region = "C:/Users/diall/Downloads/ADMIN-EXPRESS_3-2__SHP_LAMB93_FXX_2024-04-23/ADMIN-EXPRESS_3-2__SHP_LAMB93_FXX_2024-04-23/ADMIN-EXPRESS/1_DONNEES_LIVRAISON_2024-04-00116/ADE_3-2_SHP_LAMB93_FXX-ED2024-04-23/REGION.shp"
# france_shapefile <- st_read(fr_region)
# 
# st_crs(france_shapefile)
# france_shapefile <- st_transform(france_shapefile, crs = "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
# st_crs(france_shapefile)
# 
# g = ggplot(france_shapefile) +
#   geom_sf()
# g
# 
# # Excluez la région Corse
# france_shapefile <- france_shapefile[france_shapefile$NOM_M != "CORSE", ]
# st_write(france_shapefile, "cartographie/france_shapefile_sans_corse.shp")

france_shapefile <- st_read("cartographie/france_shapefile_sans_corse.shp")

g = ggplot(france_shapefile) +
  geom_sf(color ="")
g
gg = form(g)

# Carte
landworm_sf = landworm[,c("gps_x", "gps_y")]
landworm_sf <- st_as_sf(landworm_sf, coords = c("gps_x", "gps_y"))
st_crs(landworm_sf) =  "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"



carte_obs <- ggplot() +
  geom_sf(data = france_shapefile) +  
  geom_sf(data = landworm_sf, color = "red", size = 0.01) +
  labs(x = 'Longitude', y = 'Latitude',
       # title = "Map of France",
       # subtitle = '',
       caption = 'Source: LandWorm, 2024')+
  # ggsn::scalebar(location = "bottomleft", dist = 100, dist_unit = "km") +
  # cowplot::theme_cowplot()+
  theme(panel.grid.major = element_line(color = gray(.5),
                                        linetype = 'dashed',
                                        size = 0.1),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill=NA,color = 'black'),
        panel.ontop = TRUE,
        axis.text = element_text(size = 8),
        axis.title.y = element_text(vjust = 5, size = 10, face = "bold"),
        axis.title.x = element_text(size = 10, face = "bold",vjust = -1),
        axis.ticks.length = unit(0.2, "cm"),
        plot.caption = element_text(vjust = -1.5),
        plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"))

carte_obs = carte_obs +
  # blank() +
  ggsn::north(landworm_sf) +
  ggsn::scalebar(landworm_sf, dist = 50, dist_unit = "km",
           transform = TRUE, model = "WGS84",location = "bottomleft", st.size = 1)

ggsave("cartographie/carte_obs.png", plot = carte_obs, dpi = 300
       ,height = 3,width = 3
       )



# Carte spatial thining BZH, Dijon et IDF ------------------------
landworm_sf = landw_thining_non_t[,c("gps_x", "gps_y")]
set.seed(123)
ind <- sample(2, nrow(landworm_sf), replace = T, prob = c(.8, .2))
train <- landworm_sf[ind==1,]
test <- landworm_sf[ind==2,]
landworm_sf = test
landworm_sf <- st_as_sf(landworm_sf, coords = c("gps_x", "gps_y"))
st_crs(landworm_sf) =  "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

carte_obs <- ggplot() +
  geom_sf(data = france_shapefile) +  
  geom_sf(data = landworm_sf, color = "blue", size = 0.01) +
  labs(x = 'Longitude', y = 'Latitude',
       # title = "Map of France",
       # subtitle = '',
       # caption = 'Source: LandWorm, 2024'
       )+
  # ggsn::scalebar(location = "bottomleft", dist = 100, dist_unit = "km") +
  # cowplot::theme_cowplot()+
  theme(panel.grid.major = element_line(color = gray(.5),
                                        linetype = 'dashed',
                                        size = 0.1),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill=NA,color = 'black'),
        panel.ontop = TRUE,
        axis.text = element_text(size = 8),
        axis.title.y = element_text(vjust = 5, size = 10, face = "bold"),
        axis.title.x = element_text(size = 10, face = "bold",vjust = -1),
        axis.ticks.length = unit(0.2, "cm"),
        plot.caption = element_text(vjust = -1.5),
        plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"))

carte_obs = carte_obs +
  # blank() +
  ggsn::north(landworm_sf) +
  ggsn::scalebar(landworm_sf, dist = 75, dist_unit = "km",
           transform = TRUE, model = "WGS84",location = "bottomleft", st.size = 1)

ggsave("cartographie/carte_obs-thinning.png", plot = carte_obs, dpi = 300
       ,height = 2.8,width = 3
       )

gg = form(carte_obs)


# Carte spatial thining all  ------------------------
df = landworm[,c("gps_x", "gps_y", "AB_tot")]
df$AB_tot = rep("AB_tot")
thinned_dataset_full <-
  thin( loc.data = df, 
        lat.col = "gps_y", long.col = "gps_x", 
        spec.col = "AB_tot", 
        thin.par = 1, reps = 10, 
        locs.thinned.list.return = TRUE, 
        write.files = FALSE, 
        write.log.file = FALSE)

df_thine= thinned_dataset_full[[2]]
plotThin( thinned_dataset_full )

data( Heteromys_anomalus_South_America )
summary ( Heteromys_anomalus_South_America )

# Carte
landworm_sf = df_thine
# landworm_sf = df_mod_AB_tot[,c("gps_x", "gps_y", "AB_tot")]
landworm_sf <- st_as_sf(landworm_sf, coords = c("Longitude", "Latitude"))
landworm_sf <- st_as_sf(landworm_sf, coords = c("gps_x", "gps_y"))
st_crs(landworm_sf) =  "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

carte_obs <- ggplot() +
  geom_sf(data = france_shapefile) +  
  geom_sf(data = landworm_sf, color = "red", size = 0.01) +
  labs(x = 'Longitude', y = 'Latitude',
       # title = "Map of France",
       # subtitle = '',
       caption = 'Source: LandWorm, 2024')+
  # ggsn::scalebar(location = "bottomleft", dist = 100, dist_unit = "km") +
  # cowplot::theme_cowplot()+
  theme(panel.grid.major = element_line(color = gray(.5),
                                        linetype = 'dashed',
                                        size = 0.1),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill=NA,color = 'black'),
        panel.ontop = TRUE,
        axis.text = element_text(size = 8),
        axis.title.y = element_text(vjust = 5, size = 10, face = "bold"),
        axis.title.x = element_text(size = 10, face = "bold",vjust = -1),
        axis.ticks.length = unit(0.2, "cm"),
        plot.caption = element_text(vjust = -1.5),
        plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"))

carte_obs = carte_obs +
  # blank() +
  ggsn::north(landworm_sf) +
  ggsn::scalebar(landworm_sf, dist = 50, dist_unit = "km",
           transform = TRUE, model = "WGS84",location = "bottomleft", st.size = 1)


```

```{r, eval=FALSE}
tif_file_path = "C:/Users/diall/Downloads/datas/raster_modif/limon.0_5.tif"
rass = raster(tif_file_path)
 plot(rass,axe =FALSE, box =FALSE,legend=FALSE)
# image(rass)
```


<!-- <p align="center"> -->
<!--   <img src="cartographie/carte_obs.png"> -->
<!-- </p> -->


<!-- **Après thinning** -->
<p align="center">
  <img src="cartographie/carte_obs-thinning.png">
</p>



## Carte CLC
```{r, eval=FALSE}
# predictors <- readRDS("cartographie/predictors.rds")
# os_predictors = predictors[, c("gps_x", "gps_y", "clcm_lvl3")]
# 
# 
# custom_colors <- c("f" = "green", "gua" = "blue", "ng" = "orange", 
#                    "nial" = "purple", "p" = "cyan", "v" = "grey")
# 
# carte_os <- ggplot(os_predictors, aes(x = gps_x, y = gps_y, color = clcm_lvl3)) +
#   geom_point() +
#   scale_color_manual(values = custom_colors)
# carte_os
# ggsave("Results/carte_os.png", plot = carte_os, dpi = 300,height = 4,width = 6)
```

<p align="center">
  <img src="Results/carte_os.png">
</p>


## Redaction results
```{r , eval=FALSE}
# Abundance
# Calcul du test de Friedman pour comparer les prediction
df_friedman = data.frame(Abundance = AB_tot_test$AB_tot)
df_friedman$types = rep("observed")
df_friedman = rbind(df_friedman,
                    data.frame(Abundance =GLM_result_AB_tot$predit,types=rep("GLM")),
                    data.frame(Abundance =GAM_result_AB_tot$predit,types=rep("GAM")),
                    data.frame(Abundance =RF_result_AB_tot$predit,types=rep("RF")),
                    data.frame(Abundance =GBM_result_AB_tot$predit,types=rep("GBM")),
                    data.frame(Abundance =ANN_tune_AB_tot_pred,types=rep("ANN"))
                    )
df_friedman$types = as.factor(df_friedman$types)
df_friedman %>%
  group_by(types) %>%
  get_summary_stats(Abundance, type = "common")
ggboxplot(df_friedman, x = "types", y = "Abundance", add = "jitter")
# friedman_result <- friedman.test(Abundance ~ types, data = df_friedman)
# Test de somme des rangs de Wilcoxon par paires avec correction de Bonferroni
# pairwise.wilcox.test(selfesteem$score, selfesteem$time, p.adj = "bonf")

ab = c(0.22,0.26,0.43,0.43,0.35); round(sd(ab),2)
rmse_ab = c(34.57,33.06,25.20,25.30,28.94); round(sd(rmse_ab),2)

bm = c(0.23,0.24,0.35,0.32,0.27); round(sd(bm),2)
rmse_bm = c(1.69,10.50,8.76,9.30,10.50); round(sd(rmse_bm),2)

rch = c(0.36,0.44,0.59,0.59,0.40); round(sd(rch),2)
rmse_rch = c(2.18,2.04,1.75,1.75,2.16); round(sd(rmse_rch),2)



```


```{r , eval=FALSE}
df_os_pred_AB_tot = AB_tot_pred
df_os_pred_AB_tot$Abundance = df_os_pred_AB_tot$Abundance^2
df_os_pred_AB_tot = cbind(df_os_pred_AB_tot,predictors)

clc_AB_tot_pred = df_os_pred_AB_tot %>%
  group_by(clcm_lvl3) %>%
  summarise(mean_ab = round(mean(Abundance)),
            sd_ab = round(sd(Abundance))) %>% 
  as.data.frame()
clc_AB_tot_pred$type = rep("Predected")
colnames(clc_AB_tot_pred) <- c("CLC", "Mean_ab", "SD_ab", "type")

clc_AB_tot_obs = landworm_explo_non_t  %>%
  group_by(clcm_lvl3) %>%
  summarise(mean_ab = round(mean(AB_tot)),
            sd_ab = round(sd(AB_tot))) %>% 
  as.data.frame()
clc_AB_tot_obs$type = rep("Observed")
colnames(clc_AB_tot_obs) <- c("CLC", "Mean_ab", "SD_ab", "type")



comp_AB_tot = rbind(clc_AB_tot_pred,clc_AB_tot_obs)
comp_plot_AB_tot <- ggplot(comp_AB_tot, aes(x = CLC, y = Mean_ab, color = type)) +
  geom_point(position = position_dodge(width = 0.9), size = 3, alpha = 0.7) +
  geom_errorbar(aes(ymin = Mean_ab - SD_ab, ymax = Mean_ab + SD_ab), position = position_dodge(width = 0.9), width = 0.3) +
  labs(x = "CLC", y = "Abundance", title = "Comparison of observed and predicted abundance by CLC") +
  scale_color_manual(values = c("blue", "red"), name = "", labels = c("Observed", "Predicted")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  coord_flip()

comp_plot_AB_tot

```


```{r , eval=FALSE}
df_os_pred_BM_tot = BM_tot_pred
df_os_pred_BM_tot$Biomass = df_os_pred_BM_tot$Biomass^2
df_os_pred_BM_tot = cbind(df_os_pred_BM_tot,predictors)

clc_BM_tot_pred = df_os_pred_BM_tot %>%
  group_by(clcm_lvl3) %>%
  summarise(mean_ab = round(mean(Biomass)),
            sd_ab = round(sd(Biomass))) %>% 
  as.data.frame()
clc_BM_tot_pred$type = rep("Predected")
colnames(clc_BM_tot_pred) <- c("CLC", "Mean_ab", "SD_ab", "type")

clc_BM_tot_obs = landworm_explo_non_t  %>%
  group_by(clcm_lvl3) %>%
  summarise(mean_ab = round(mean(BM_tot, na.rm=TRUE)),
            sd_ab = round(sd(BM_tot, na.rm=TRUE))) %>% 
  as.data.frame()
clc_BM_tot_obs$type = rep("Observed")
colnames(clc_BM_tot_obs) <- c("CLC", "Mean_ab", "SD_ab", "type")



comp_BM_tot = rbind(clc_BM_tot_pred,clc_BM_tot_obs)
comp_plot_BM_tot <- ggplot(comp_BM_tot, aes(x = CLC, y = Mean_ab, color = type)) +
  geom_point(position = position_dodge(width = 0.9), size = 3, alpha = 0.7) +
  geom_errorbar(aes(ymin = Mean_ab - SD_ab, ymax = Mean_ab + SD_ab), position = position_dodge(width = 0.9), width = 0.3) +
  labs(x = "CLC", y = "Biomass", title = "Comparison of observed and predicted Biomass by CLC") +
  scale_color_manual(values = c("blue", "red"), name = "", labels = c("Observed", "Predicted")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  coord_flip()

comp_plot_BM_tot

```


```{r , eval=FALSE}
df_os_pred_Richesse_tot = Richesse_tot_pred
# df_os_pred_Richesse_tot$Richness = df_os_pred_Richesse_tot$Richness^2
df_os_pred_Richesse_tot = cbind(df_os_pred_Richesse_tot,predictors)

clc_Richesse_tot_pred = df_os_pred_Richesse_tot %>%
  group_by(clcm_lvl3) %>%
  summarise(mean_ab = round(mean(Richness)),
            sd_ab = round(sd(Richness))) %>% 
  as.data.frame()
clc_Richesse_tot_pred$type = rep("Predected")
colnames(clc_Richesse_tot_pred) <- c("CLC", "Mean_ab", "SD_ab", "type")

clc_Richesse_tot_obs = landworm_explo_non_t  %>%
  group_by(clcm_lvl3) %>%
  summarise(mean_ab = round(mean(Richesse_tot)),
            sd_ab = round(sd(Richesse_tot))) %>% 
  as.data.frame()
clc_Richesse_tot_obs$type = rep("Observed")
colnames(clc_Richesse_tot_obs) <- c("CLC", "Mean_ab", "SD_ab", "type")



comp_Richesse_tot = rbind(clc_Richesse_tot_pred,clc_Richesse_tot_obs)
comp_plot_Richesse_tot <- ggplot(comp_Richesse_tot, aes(x = CLC, y = Mean_ab, color = type)) +
  geom_point(position = position_dodge(width = 0.9), size = 3, alpha = 0.7) +
  geom_errorbar(aes(ymin = Mean_ab - SD_ab, ymax = Mean_ab + SD_ab), position = position_dodge(width = 0.9), width = 0.3) +
  labs(x = "CLC", y = "Richness", title = "Comparison of observed and predicted Richness by CLC") +
  scale_color_manual(values = c("blue", "red"), name = "", labels = c("Observed", "Predicted")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  coord_flip()

comp_plot_Richesse_tot

```


```{r, eval=FALSE}
data_min_mean_max = landworm_explo_non_t [, c(9:15, 17:18)]

df = data.frame(var = character(),min=numeric(), mean = numeric(), max = numeric())

for (i in names(data_min_mean_max)){
  
 df_2 = data.frame(var = i,
                  min=min(data_min_mean_max[,i], na.rm=TRUE), 
                  mean = mean(data_min_mean_max[,i], na.rm=TRUE), 
                  max = max(data_min_mean_max[,i], na.rm=TRUE)
                            )
 df= rbind (df, df_2)
}
df

```


# Questions

Quelles dates de prevelement pour la prediction


## Additional information

<br/>
<br/>
<!-- <br/> -->
<!-- See [species explorations](https://posit.cloud/content/7997063){target="_blank"} -->
<br/>
<br/>
All the material from my internship, including scripts and datasets, is available on my [GitHub](https://github.com/diallo-abdou/stage_abdou_m2){target="_blank"} and my [Rpubs.](https://rpubs.com/Abdou_diallo){target="_blank"}

# {.unnumbered}

<div style="text-align: center; font-size: larger"><strong>Thank you for your attention</strong></div>


